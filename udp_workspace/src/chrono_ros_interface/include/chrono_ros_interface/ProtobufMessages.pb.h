// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtobufMessages.proto

#ifndef PROTOBUF_ProtobufMessages_2eproto__INCLUDED
#define PROTOBUF_ProtobufMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace DriverMessages {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_ProtobufMessages_2eproto();
void protobuf_AssignDesc_ProtobufMessages_2eproto();
void protobuf_ShutdownFile_ProtobufMessages_2eproto();

class Vector;
class cones;
class control;
class exit;
class gps;
class imu;
class lidar;
class light;
class time;
class vehicle;

// ===================================================================

class Vector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.Vector) */ {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();

  void Swap(Vector* other);

  // implements Message ----------------------------------------------

  inline Vector* New() const { return New(NULL); }

  Vector* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:DriverMessages.Vector)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_ProtobufMessages_2eproto();
  friend void protobuf_AssignDesc_ProtobufMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtobufMessages_2eproto();

  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// -------------------------------------------------------------------

class lidar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.lidar) */ {
 public:
  lidar();
  virtual ~lidar();

  lidar(const lidar& from);

  inline lidar& operator=(const lidar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lidar& default_instance();

  void Swap(lidar* other);

  // implements Message ----------------------------------------------

  inline lidar* New() const { return New(NULL); }

  lidar* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lidar& from);
  void MergeFrom(const lidar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(lidar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DriverMessages.Vector points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::DriverMessages::Vector& points(int index) const;
  ::DriverMessages::Vector* mutable_points(int index);
  ::DriverMessages::Vector* add_points();
  ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >&
      points() const;

  // @@protoc_insertion_point(class_scope:DriverMessages.lidar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector > points_;
  friend void  protobuf_AddDesc_ProtobufMessages_2eproto();
  friend void protobuf_AssignDesc_ProtobufMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtobufMessages_2eproto();

  void InitAsDefaultInstance();
  static lidar* default_instance_;
};
// -------------------------------------------------------------------

class gps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.gps) */ {
 public:
  gps();
  virtual ~gps();

  gps(const gps& from);

  inline gps& operator=(const gps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gps& default_instance();

  void Swap(gps* other);

  // implements Message ----------------------------------------------

  inline gps* New() const { return New(NULL); }

  gps* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gps& from);
  void MergeFrom(const gps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(gps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double longitude = 1;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  double longitude() const;
  void set_longitude(double value);

  // required double latitude = 2;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  double latitude() const;
  void set_latitude(double value);

  // required double altitude = 3;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  double altitude() const;
  void set_altitude(double value);

  // @@protoc_insertion_point(class_scope:DriverMessages.gps)
 private:
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double longitude_;
  double latitude_;
  double altitude_;
  friend void  protobuf_AddDesc_ProtobufMessages_2eproto();
  friend void protobuf_AssignDesc_ProtobufMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtobufMessages_2eproto();

  void InitAsDefaultInstance();
  static gps* default_instance_;
};
// -------------------------------------------------------------------

class imu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.imu) */ {
 public:
  imu();
  virtual ~imu();

  imu(const imu& from);

  inline imu& operator=(const imu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const imu& default_instance();

  void Swap(imu* other);

  // implements Message ----------------------------------------------

  inline imu* New() const { return New(NULL); }

  imu* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const imu& from);
  void MergeFrom(const imu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(imu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DriverMessages.Vector angular_velocity = 1;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 1;
  const ::DriverMessages::Vector& angular_velocity() const;
  ::DriverMessages::Vector* mutable_angular_velocity();
  ::DriverMessages::Vector* release_angular_velocity();
  void set_allocated_angular_velocity(::DriverMessages::Vector* angular_velocity);

  // required .DriverMessages.Vector linear_acceleration = 2;
  bool has_linear_acceleration() const;
  void clear_linear_acceleration();
  static const int kLinearAccelerationFieldNumber = 2;
  const ::DriverMessages::Vector& linear_acceleration() const;
  ::DriverMessages::Vector* mutable_linear_acceleration();
  ::DriverMessages::Vector* release_linear_acceleration();
  void set_allocated_linear_acceleration(::DriverMessages::Vector* linear_acceleration);

  // required .DriverMessages.Vector orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  const ::DriverMessages::Vector& orientation() const;
  ::DriverMessages::Vector* mutable_orientation();
  ::DriverMessages::Vector* release_orientation();
  void set_allocated_orientation(::DriverMessages::Vector* orientation);

  // @@protoc_insertion_point(class_scope:DriverMessages.imu)
 private:
  inline void set_has_angular_velocity();
  inline void clear_has_angular_velocity();
  inline void set_has_linear_acceleration();
  inline void clear_has_linear_acceleration();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DriverMessages::Vector* angular_velocity_;
  ::DriverMessages::Vector* linear_acceleration_;
  ::DriverMessages::Vector* orientation_;
  friend void  protobuf_AddDesc_ProtobufMessages_2eproto();
  friend void protobuf_AssignDesc_ProtobufMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtobufMessages_2eproto();

  void InitAsDefaultInstance();
  static imu* default_instance_;
};
// -------------------------------------------------------------------

class vehicle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.vehicle) */ {
 public:
  vehicle();
  virtual ~vehicle();

  vehicle(const vehicle& from);

  inline vehicle& operator=(const vehicle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vehicle& default_instance();

  void Swap(vehicle* other);

  // implements Message ----------------------------------------------

  inline vehicle* New() const { return New(NULL); }

  vehicle* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vehicle& from);
  void MergeFrom(const vehicle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(vehicle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:DriverMessages.vehicle)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_ProtobufMessages_2eproto();
  friend void protobuf_AssignDesc_ProtobufMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtobufMessages_2eproto();

  void InitAsDefaultInstance();
  static vehicle* default_instance_;
};
// -------------------------------------------------------------------

class control : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.control) */ {
 public:
  control();
  virtual ~control();

  control(const control& from);

  inline control& operator=(const control& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const control& default_instance();

  void Swap(control* other);

  // implements Message ----------------------------------------------

  inline control* New() const { return New(NULL); }

  control* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const control& from);
  void MergeFrom(const control& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(control* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double throttle = 1;
  bool has_throttle() const;
  void clear_throttle();
  static const int kThrottleFieldNumber = 1;
  double throttle() const;
  void set_throttle(double value);

  // required double steering = 2;
  bool has_steering() const;
  void clear_steering();
  static const int kSteeringFieldNumber = 2;
  double steering() const;
  void set_steering(double value);

  // required double braking = 3;
  bool has_braking() const;
  void clear_braking();
  static const int kBrakingFieldNumber = 3;
  double braking() const;
  void set_braking(double value);

  // @@protoc_insertion_point(class_scope:DriverMessages.control)
 private:
  inline void set_has_throttle();
  inline void clear_has_throttle();
  inline void set_has_steering();
  inline void clear_has_steering();
  inline void set_has_braking();
  inline void clear_has_braking();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double throttle_;
  double steering_;
  double braking_;
  friend void  protobuf_AddDesc_ProtobufMessages_2eproto();
  friend void protobuf_AssignDesc_ProtobufMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtobufMessages_2eproto();

  void InitAsDefaultInstance();
  static control* default_instance_;
};
// -------------------------------------------------------------------

class time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.time) */ {
 public:
  time();
  virtual ~time();

  time(const time& from);

  inline time& operator=(const time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const time& default_instance();

  void Swap(time* other);

  // implements Message ----------------------------------------------

  inline time* New() const { return New(NULL); }

  time* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const time& from);
  void MergeFrom(const time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double t = 1;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 1;
  double t() const;
  void set_t(double value);

  // @@protoc_insertion_point(class_scope:DriverMessages.time)
 private:
  inline void set_has_t();
  inline void clear_has_t();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double t_;
  friend void  protobuf_AddDesc_ProtobufMessages_2eproto();
  friend void protobuf_AssignDesc_ProtobufMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtobufMessages_2eproto();

  void InitAsDefaultInstance();
  static time* default_instance_;
};
// -------------------------------------------------------------------

class light : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.light) */ {
 public:
  light();
  virtual ~light();

  light(const light& from);

  inline light& operator=(const light& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const light& default_instance();

  void Swap(light* other);

  // implements Message ----------------------------------------------

  inline light* New() const { return New(NULL); }

  light* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const light& from);
  void MergeFrom(const light& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(light* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double xpos = 1;
  bool has_xpos() const;
  void clear_xpos();
  static const int kXposFieldNumber = 1;
  double xpos() const;
  void set_xpos(double value);

  // required double ypos = 2;
  bool has_ypos() const;
  void clear_ypos();
  static const int kYposFieldNumber = 2;
  double ypos() const;
  void set_ypos(double value);

  // required double xdir = 3;
  bool has_xdir() const;
  void clear_xdir();
  static const int kXdirFieldNumber = 3;
  double xdir() const;
  void set_xdir(double value);

  // required double ydir = 4;
  bool has_ydir() const;
  void clear_ydir();
  static const int kYdirFieldNumber = 4;
  double ydir() const;
  void set_ydir(double value);

  // @@protoc_insertion_point(class_scope:DriverMessages.light)
 private:
  inline void set_has_xpos();
  inline void clear_has_xpos();
  inline void set_has_ypos();
  inline void clear_has_ypos();
  inline void set_has_xdir();
  inline void clear_has_xdir();
  inline void set_has_ydir();
  inline void clear_has_ydir();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double xpos_;
  double ypos_;
  double xdir_;
  double ydir_;
  friend void  protobuf_AddDesc_ProtobufMessages_2eproto();
  friend void protobuf_AssignDesc_ProtobufMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtobufMessages_2eproto();

  void InitAsDefaultInstance();
  static light* default_instance_;
};
// -------------------------------------------------------------------

class cones : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.cones) */ {
 public:
  cones();
  virtual ~cones();

  cones(const cones& from);

  inline cones& operator=(const cones& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cones& default_instance();

  void Swap(cones* other);

  // implements Message ----------------------------------------------

  inline cones* New() const { return New(NULL); }

  cones* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cones& from);
  void MergeFrom(const cones& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(cones* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DriverMessages.Vector blue_cones = 1;
  int blue_cones_size() const;
  void clear_blue_cones();
  static const int kBlueConesFieldNumber = 1;
  const ::DriverMessages::Vector& blue_cones(int index) const;
  ::DriverMessages::Vector* mutable_blue_cones(int index);
  ::DriverMessages::Vector* add_blue_cones();
  ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >*
      mutable_blue_cones();
  const ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >&
      blue_cones() const;

  // repeated .DriverMessages.Vector yellow_cones = 2;
  int yellow_cones_size() const;
  void clear_yellow_cones();
  static const int kYellowConesFieldNumber = 2;
  const ::DriverMessages::Vector& yellow_cones(int index) const;
  ::DriverMessages::Vector* mutable_yellow_cones(int index);
  ::DriverMessages::Vector* add_yellow_cones();
  ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >*
      mutable_yellow_cones();
  const ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >&
      yellow_cones() const;

  // @@protoc_insertion_point(class_scope:DriverMessages.cones)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector > blue_cones_;
  ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector > yellow_cones_;
  friend void  protobuf_AddDesc_ProtobufMessages_2eproto();
  friend void protobuf_AssignDesc_ProtobufMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtobufMessages_2eproto();

  void InitAsDefaultInstance();
  static cones* default_instance_;
};
// -------------------------------------------------------------------

class exit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.exit) */ {
 public:
  exit();
  virtual ~exit();

  exit(const exit& from);

  inline exit& operator=(const exit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exit& default_instance();

  void Swap(exit* other);

  // implements Message ----------------------------------------------

  inline exit* New() const { return New(NULL); }

  exit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exit& from);
  void MergeFrom(const exit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(exit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:DriverMessages.exit)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  friend void  protobuf_AddDesc_ProtobufMessages_2eproto();
  friend void protobuf_AssignDesc_ProtobufMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtobufMessages_2eproto();

  void InitAsDefaultInstance();
  static exit* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Vector

// required float x = 1;
inline bool Vector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector::x() const {
  // @@protoc_insertion_point(field_get:DriverMessages.Vector.x)
  return x_;
}
inline void Vector::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.Vector.x)
}

// required float y = 2;
inline bool Vector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector::y() const {
  // @@protoc_insertion_point(field_get:DriverMessages.Vector.y)
  return y_;
}
inline void Vector::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.Vector.y)
}

// required float z = 3;
inline bool Vector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector::z() const {
  // @@protoc_insertion_point(field_get:DriverMessages.Vector.z)
  return z_;
}
inline void Vector::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.Vector.z)
}

// -------------------------------------------------------------------

// lidar

// repeated .DriverMessages.Vector points = 1;
inline int lidar::points_size() const {
  return points_.size();
}
inline void lidar::clear_points() {
  points_.Clear();
}
inline const ::DriverMessages::Vector& lidar::points(int index) const {
  // @@protoc_insertion_point(field_get:DriverMessages.lidar.points)
  return points_.Get(index);
}
inline ::DriverMessages::Vector* lidar::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:DriverMessages.lidar.points)
  return points_.Mutable(index);
}
inline ::DriverMessages::Vector* lidar::add_points() {
  // @@protoc_insertion_point(field_add:DriverMessages.lidar.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >*
lidar::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:DriverMessages.lidar.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >&
lidar::points() const {
  // @@protoc_insertion_point(field_list:DriverMessages.lidar.points)
  return points_;
}

// -------------------------------------------------------------------

// gps

// required double longitude = 1;
inline bool gps::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gps::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gps::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gps::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double gps::longitude() const {
  // @@protoc_insertion_point(field_get:DriverMessages.gps.longitude)
  return longitude_;
}
inline void gps::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.gps.longitude)
}

// required double latitude = 2;
inline bool gps::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gps::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gps::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gps::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double gps::latitude() const {
  // @@protoc_insertion_point(field_get:DriverMessages.gps.latitude)
  return latitude_;
}
inline void gps::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.gps.latitude)
}

// required double altitude = 3;
inline bool gps::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gps::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gps::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gps::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double gps::altitude() const {
  // @@protoc_insertion_point(field_get:DriverMessages.gps.altitude)
  return altitude_;
}
inline void gps::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.gps.altitude)
}

// -------------------------------------------------------------------

// imu

// required .DriverMessages.Vector angular_velocity = 1;
inline bool imu::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void imu::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void imu::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void imu::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->::DriverMessages::Vector::Clear();
  clear_has_angular_velocity();
}
inline const ::DriverMessages::Vector& imu::angular_velocity() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_ : *default_instance_->angular_velocity_;
}
inline ::DriverMessages::Vector* imu::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::DriverMessages::Vector;
  }
  // @@protoc_insertion_point(field_mutable:DriverMessages.imu.angular_velocity)
  return angular_velocity_;
}
inline ::DriverMessages::Vector* imu::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:DriverMessages.imu.angular_velocity)
  clear_has_angular_velocity();
  ::DriverMessages::Vector* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void imu::set_allocated_angular_velocity(::DriverMessages::Vector* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:DriverMessages.imu.angular_velocity)
}

// required .DriverMessages.Vector linear_acceleration = 2;
inline bool imu::has_linear_acceleration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void imu::set_has_linear_acceleration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void imu::clear_has_linear_acceleration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void imu::clear_linear_acceleration() {
  if (linear_acceleration_ != NULL) linear_acceleration_->::DriverMessages::Vector::Clear();
  clear_has_linear_acceleration();
}
inline const ::DriverMessages::Vector& imu::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.linear_acceleration)
  return linear_acceleration_ != NULL ? *linear_acceleration_ : *default_instance_->linear_acceleration_;
}
inline ::DriverMessages::Vector* imu::mutable_linear_acceleration() {
  set_has_linear_acceleration();
  if (linear_acceleration_ == NULL) {
    linear_acceleration_ = new ::DriverMessages::Vector;
  }
  // @@protoc_insertion_point(field_mutable:DriverMessages.imu.linear_acceleration)
  return linear_acceleration_;
}
inline ::DriverMessages::Vector* imu::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:DriverMessages.imu.linear_acceleration)
  clear_has_linear_acceleration();
  ::DriverMessages::Vector* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
inline void imu::set_allocated_linear_acceleration(::DriverMessages::Vector* linear_acceleration) {
  delete linear_acceleration_;
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    set_has_linear_acceleration();
  } else {
    clear_has_linear_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:DriverMessages.imu.linear_acceleration)
}

// required .DriverMessages.Vector orientation = 3;
inline bool imu::has_orientation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void imu::set_has_orientation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void imu::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void imu::clear_orientation() {
  if (orientation_ != NULL) orientation_->::DriverMessages::Vector::Clear();
  clear_has_orientation();
}
inline const ::DriverMessages::Vector& imu::orientation() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::DriverMessages::Vector* imu::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::DriverMessages::Vector;
  }
  // @@protoc_insertion_point(field_mutable:DriverMessages.imu.orientation)
  return orientation_;
}
inline ::DriverMessages::Vector* imu::release_orientation() {
  // @@protoc_insertion_point(field_release:DriverMessages.imu.orientation)
  clear_has_orientation();
  ::DriverMessages::Vector* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void imu::set_allocated_orientation(::DriverMessages::Vector* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:DriverMessages.imu.orientation)
}

// -------------------------------------------------------------------

// vehicle

// required double x = 1;
inline bool vehicle::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void vehicle::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void vehicle::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void vehicle::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double vehicle::x() const {
  // @@protoc_insertion_point(field_get:DriverMessages.vehicle.x)
  return x_;
}
inline void vehicle::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.vehicle.x)
}

// required double y = 2;
inline bool vehicle::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void vehicle::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void vehicle::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void vehicle::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double vehicle::y() const {
  // @@protoc_insertion_point(field_get:DriverMessages.vehicle.y)
  return y_;
}
inline void vehicle::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.vehicle.y)
}

// required double z = 3;
inline bool vehicle::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void vehicle::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void vehicle::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void vehicle::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double vehicle::z() const {
  // @@protoc_insertion_point(field_get:DriverMessages.vehicle.z)
  return z_;
}
inline void vehicle::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.vehicle.z)
}

// -------------------------------------------------------------------

// control

// required double throttle = 1;
inline bool control::has_throttle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void control::set_has_throttle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void control::clear_has_throttle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void control::clear_throttle() {
  throttle_ = 0;
  clear_has_throttle();
}
inline double control::throttle() const {
  // @@protoc_insertion_point(field_get:DriverMessages.control.throttle)
  return throttle_;
}
inline void control::set_throttle(double value) {
  set_has_throttle();
  throttle_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.control.throttle)
}

// required double steering = 2;
inline bool control::has_steering() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void control::set_has_steering() {
  _has_bits_[0] |= 0x00000002u;
}
inline void control::clear_has_steering() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void control::clear_steering() {
  steering_ = 0;
  clear_has_steering();
}
inline double control::steering() const {
  // @@protoc_insertion_point(field_get:DriverMessages.control.steering)
  return steering_;
}
inline void control::set_steering(double value) {
  set_has_steering();
  steering_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.control.steering)
}

// required double braking = 3;
inline bool control::has_braking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void control::set_has_braking() {
  _has_bits_[0] |= 0x00000004u;
}
inline void control::clear_has_braking() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void control::clear_braking() {
  braking_ = 0;
  clear_has_braking();
}
inline double control::braking() const {
  // @@protoc_insertion_point(field_get:DriverMessages.control.braking)
  return braking_;
}
inline void control::set_braking(double value) {
  set_has_braking();
  braking_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.control.braking)
}

// -------------------------------------------------------------------

// time

// required double t = 1;
inline bool time::has_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void time::set_has_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void time::clear_has_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void time::clear_t() {
  t_ = 0;
  clear_has_t();
}
inline double time::t() const {
  // @@protoc_insertion_point(field_get:DriverMessages.time.t)
  return t_;
}
inline void time::set_t(double value) {
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.time.t)
}

// -------------------------------------------------------------------

// light

// required double xpos = 1;
inline bool light::has_xpos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void light::set_has_xpos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void light::clear_has_xpos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void light::clear_xpos() {
  xpos_ = 0;
  clear_has_xpos();
}
inline double light::xpos() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.xpos)
  return xpos_;
}
inline void light::set_xpos(double value) {
  set_has_xpos();
  xpos_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.xpos)
}

// required double ypos = 2;
inline bool light::has_ypos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void light::set_has_ypos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void light::clear_has_ypos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void light::clear_ypos() {
  ypos_ = 0;
  clear_has_ypos();
}
inline double light::ypos() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.ypos)
  return ypos_;
}
inline void light::set_ypos(double value) {
  set_has_ypos();
  ypos_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.ypos)
}

// required double xdir = 3;
inline bool light::has_xdir() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void light::set_has_xdir() {
  _has_bits_[0] |= 0x00000004u;
}
inline void light::clear_has_xdir() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void light::clear_xdir() {
  xdir_ = 0;
  clear_has_xdir();
}
inline double light::xdir() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.xdir)
  return xdir_;
}
inline void light::set_xdir(double value) {
  set_has_xdir();
  xdir_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.xdir)
}

// required double ydir = 4;
inline bool light::has_ydir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void light::set_has_ydir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void light::clear_has_ydir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void light::clear_ydir() {
  ydir_ = 0;
  clear_has_ydir();
}
inline double light::ydir() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.ydir)
  return ydir_;
}
inline void light::set_ydir(double value) {
  set_has_ydir();
  ydir_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.ydir)
}

// -------------------------------------------------------------------

// cones

// repeated .DriverMessages.Vector blue_cones = 1;
inline int cones::blue_cones_size() const {
  return blue_cones_.size();
}
inline void cones::clear_blue_cones() {
  blue_cones_.Clear();
}
inline const ::DriverMessages::Vector& cones::blue_cones(int index) const {
  // @@protoc_insertion_point(field_get:DriverMessages.cones.blue_cones)
  return blue_cones_.Get(index);
}
inline ::DriverMessages::Vector* cones::mutable_blue_cones(int index) {
  // @@protoc_insertion_point(field_mutable:DriverMessages.cones.blue_cones)
  return blue_cones_.Mutable(index);
}
inline ::DriverMessages::Vector* cones::add_blue_cones() {
  // @@protoc_insertion_point(field_add:DriverMessages.cones.blue_cones)
  return blue_cones_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >*
cones::mutable_blue_cones() {
  // @@protoc_insertion_point(field_mutable_list:DriverMessages.cones.blue_cones)
  return &blue_cones_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >&
cones::blue_cones() const {
  // @@protoc_insertion_point(field_list:DriverMessages.cones.blue_cones)
  return blue_cones_;
}

// repeated .DriverMessages.Vector yellow_cones = 2;
inline int cones::yellow_cones_size() const {
  return yellow_cones_.size();
}
inline void cones::clear_yellow_cones() {
  yellow_cones_.Clear();
}
inline const ::DriverMessages::Vector& cones::yellow_cones(int index) const {
  // @@protoc_insertion_point(field_get:DriverMessages.cones.yellow_cones)
  return yellow_cones_.Get(index);
}
inline ::DriverMessages::Vector* cones::mutable_yellow_cones(int index) {
  // @@protoc_insertion_point(field_mutable:DriverMessages.cones.yellow_cones)
  return yellow_cones_.Mutable(index);
}
inline ::DriverMessages::Vector* cones::add_yellow_cones() {
  // @@protoc_insertion_point(field_add:DriverMessages.cones.yellow_cones)
  return yellow_cones_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >*
cones::mutable_yellow_cones() {
  // @@protoc_insertion_point(field_mutable_list:DriverMessages.cones.yellow_cones)
  return &yellow_cones_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DriverMessages::Vector >&
cones::yellow_cones() const {
  // @@protoc_insertion_point(field_list:DriverMessages.cones.yellow_cones)
  return yellow_cones_;
}

// -------------------------------------------------------------------

// exit

// required string code = 1;
inline bool exit::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exit::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exit::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exit::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code();
}
inline const ::std::string& exit::code() const {
  // @@protoc_insertion_point(field_get:DriverMessages.exit.code)
  return code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void exit::set_code(const ::std::string& value) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DriverMessages.exit.code)
}
inline void exit::set_code(const char* value) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DriverMessages.exit.code)
}
inline void exit::set_code(const char* value, size_t size) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DriverMessages.exit.code)
}
inline ::std::string* exit::mutable_code() {
  set_has_code();
  // @@protoc_insertion_point(field_mutable:DriverMessages.exit.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* exit::release_code() {
  // @@protoc_insertion_point(field_release:DriverMessages.exit.code)
  clear_has_code();
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void exit::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    set_has_code();
  } else {
    clear_has_code();
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:DriverMessages.exit.code)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DriverMessages

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtobufMessages_2eproto__INCLUDED
