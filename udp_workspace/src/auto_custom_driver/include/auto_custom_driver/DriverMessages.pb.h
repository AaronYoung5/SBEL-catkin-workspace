// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DriverMessages.proto

#ifndef PROTOBUF_DriverMessages_2eproto__INCLUDED
#define PROTOBUF_DriverMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace DriverMessages {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_DriverMessages_2eproto();
void protobuf_AssignDesc_DriverMessages_2eproto();
void protobuf_ShutdownFile_DriverMessages_2eproto();

class control;
class gps;
class imu;
class lidar;
class light;
class time;

// ===================================================================

class lidar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.lidar) */ {
 public:
  lidar();
  virtual ~lidar();

  lidar(const lidar& from);

  inline lidar& operator=(const lidar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lidar& default_instance();

  void Swap(lidar* other);

  // implements Message ----------------------------------------------

  inline lidar* New() const { return New(NULL); }

  lidar* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lidar& from);
  void MergeFrom(const lidar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(lidar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField< double >&
      data() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:DriverMessages.lidar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > data_;
  friend void  protobuf_AddDesc_DriverMessages_2eproto();
  friend void protobuf_AssignDesc_DriverMessages_2eproto();
  friend void protobuf_ShutdownFile_DriverMessages_2eproto();

  void InitAsDefaultInstance();
  static lidar* default_instance_;
};
// -------------------------------------------------------------------

class gps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.gps) */ {
 public:
  gps();
  virtual ~gps();

  gps(const gps& from);

  inline gps& operator=(const gps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gps& default_instance();

  void Swap(gps* other);

  // implements Message ----------------------------------------------

  inline gps* New() const { return New(NULL); }

  gps* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gps& from);
  void MergeFrom(const gps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(gps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double longitude = 1;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  double longitude() const;
  void set_longitude(double value);

  // required double latitude = 2;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  double latitude() const;
  void set_latitude(double value);

  // required double altitude = 3;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  double altitude() const;
  void set_altitude(double value);

  // @@protoc_insertion_point(class_scope:DriverMessages.gps)
 private:
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double longitude_;
  double latitude_;
  double altitude_;
  friend void  protobuf_AddDesc_DriverMessages_2eproto();
  friend void protobuf_AssignDesc_DriverMessages_2eproto();
  friend void protobuf_ShutdownFile_DriverMessages_2eproto();

  void InitAsDefaultInstance();
  static gps* default_instance_;
};
// -------------------------------------------------------------------

class imu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.imu) */ {
 public:
  imu();
  virtual ~imu();

  imu(const imu& from);

  inline imu& operator=(const imu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const imu& default_instance();

  void Swap(imu* other);

  // implements Message ----------------------------------------------

  inline imu* New() const { return New(NULL); }

  imu* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const imu& from);
  void MergeFrom(const imu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(imu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double q0 = 1;
  bool has_q0() const;
  void clear_q0();
  static const int kQ0FieldNumber = 1;
  double q0() const;
  void set_q0(double value);

  // required double q1 = 2;
  bool has_q1() const;
  void clear_q1();
  static const int kQ1FieldNumber = 2;
  double q1() const;
  void set_q1(double value);

  // required double q2 = 3;
  bool has_q2() const;
  void clear_q2();
  static const int kQ2FieldNumber = 3;
  double q2() const;
  void set_q2(double value);

  // required double q3 = 4;
  bool has_q3() const;
  void clear_q3();
  static const int kQ3FieldNumber = 4;
  double q3() const;
  void set_q3(double value);

  // @@protoc_insertion_point(class_scope:DriverMessages.imu)
 private:
  inline void set_has_q0();
  inline void clear_has_q0();
  inline void set_has_q1();
  inline void clear_has_q1();
  inline void set_has_q2();
  inline void clear_has_q2();
  inline void set_has_q3();
  inline void clear_has_q3();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double q0_;
  double q1_;
  double q2_;
  double q3_;
  friend void  protobuf_AddDesc_DriverMessages_2eproto();
  friend void protobuf_AssignDesc_DriverMessages_2eproto();
  friend void protobuf_ShutdownFile_DriverMessages_2eproto();

  void InitAsDefaultInstance();
  static imu* default_instance_;
};
// -------------------------------------------------------------------

class control : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.control) */ {
 public:
  control();
  virtual ~control();

  control(const control& from);

  inline control& operator=(const control& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const control& default_instance();

  void Swap(control* other);

  // implements Message ----------------------------------------------

  inline control* New() const { return New(NULL); }

  control* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const control& from);
  void MergeFrom(const control& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(control* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double throttle = 1;
  bool has_throttle() const;
  void clear_throttle();
  static const int kThrottleFieldNumber = 1;
  double throttle() const;
  void set_throttle(double value);

  // required double steering = 2;
  bool has_steering() const;
  void clear_steering();
  static const int kSteeringFieldNumber = 2;
  double steering() const;
  void set_steering(double value);

  // required double braking = 3;
  bool has_braking() const;
  void clear_braking();
  static const int kBrakingFieldNumber = 3;
  double braking() const;
  void set_braking(double value);

  // @@protoc_insertion_point(class_scope:DriverMessages.control)
 private:
  inline void set_has_throttle();
  inline void clear_has_throttle();
  inline void set_has_steering();
  inline void clear_has_steering();
  inline void set_has_braking();
  inline void clear_has_braking();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double throttle_;
  double steering_;
  double braking_;
  friend void  protobuf_AddDesc_DriverMessages_2eproto();
  friend void protobuf_AssignDesc_DriverMessages_2eproto();
  friend void protobuf_ShutdownFile_DriverMessages_2eproto();

  void InitAsDefaultInstance();
  static control* default_instance_;
};
// -------------------------------------------------------------------

class time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.time) */ {
 public:
  time();
  virtual ~time();

  time(const time& from);

  inline time& operator=(const time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const time& default_instance();

  void Swap(time* other);

  // implements Message ----------------------------------------------

  inline time* New() const { return New(NULL); }

  time* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const time& from);
  void MergeFrom(const time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double t = 1;
  bool has_t() const;
  void clear_t();
  static const int kTFieldNumber = 1;
  double t() const;
  void set_t(double value);

  // @@protoc_insertion_point(class_scope:DriverMessages.time)
 private:
  inline void set_has_t();
  inline void clear_has_t();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double t_;
  friend void  protobuf_AddDesc_DriverMessages_2eproto();
  friend void protobuf_AssignDesc_DriverMessages_2eproto();
  friend void protobuf_ShutdownFile_DriverMessages_2eproto();

  void InitAsDefaultInstance();
  static time* default_instance_;
};
// -------------------------------------------------------------------

class light : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DriverMessages.light) */ {
 public:
  light();
  virtual ~light();

  light(const light& from);

  inline light& operator=(const light& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const light& default_instance();

  void Swap(light* other);

  // implements Message ----------------------------------------------

  inline light* New() const { return New(NULL); }

  light* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const light& from);
  void MergeFrom(const light& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(light* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double xpos = 1;
  bool has_xpos() const;
  void clear_xpos();
  static const int kXposFieldNumber = 1;
  double xpos() const;
  void set_xpos(double value);

  // required double ypos = 2;
  bool has_ypos() const;
  void clear_ypos();
  static const int kYposFieldNumber = 2;
  double ypos() const;
  void set_ypos(double value);

  // required double xdir = 3;
  bool has_xdir() const;
  void clear_xdir();
  static const int kXdirFieldNumber = 3;
  double xdir() const;
  void set_xdir(double value);

  // required double ydir = 4;
  bool has_ydir() const;
  void clear_ydir();
  static const int kYdirFieldNumber = 4;
  double ydir() const;
  void set_ydir(double value);

  // @@protoc_insertion_point(class_scope:DriverMessages.light)
 private:
  inline void set_has_xpos();
  inline void clear_has_xpos();
  inline void set_has_ypos();
  inline void clear_has_ypos();
  inline void set_has_xdir();
  inline void clear_has_xdir();
  inline void set_has_ydir();
  inline void clear_has_ydir();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double xpos_;
  double ypos_;
  double xdir_;
  double ydir_;
  friend void  protobuf_AddDesc_DriverMessages_2eproto();
  friend void protobuf_AssignDesc_DriverMessages_2eproto();
  friend void protobuf_ShutdownFile_DriverMessages_2eproto();

  void InitAsDefaultInstance();
  static light* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// lidar

// repeated double data = 1;
inline int lidar::data_size() const {
  return data_.size();
}
inline void lidar::clear_data() {
  data_.Clear();
}
inline double lidar::data(int index) const {
  // @@protoc_insertion_point(field_get:DriverMessages.lidar.data)
  return data_.Get(index);
}
inline void lidar::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:DriverMessages.lidar.data)
}
inline void lidar::add_data(double value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:DriverMessages.lidar.data)
}
inline const ::google::protobuf::RepeatedField< double >&
lidar::data() const {
  // @@protoc_insertion_point(field_list:DriverMessages.lidar.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
lidar::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:DriverMessages.lidar.data)
  return &data_;
}

// -------------------------------------------------------------------

// gps

// required double longitude = 1;
inline bool gps::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gps::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gps::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gps::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double gps::longitude() const {
  // @@protoc_insertion_point(field_get:DriverMessages.gps.longitude)
  return longitude_;
}
inline void gps::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.gps.longitude)
}

// required double latitude = 2;
inline bool gps::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gps::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gps::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gps::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double gps::latitude() const {
  // @@protoc_insertion_point(field_get:DriverMessages.gps.latitude)
  return latitude_;
}
inline void gps::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.gps.latitude)
}

// required double altitude = 3;
inline bool gps::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gps::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gps::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gps::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double gps::altitude() const {
  // @@protoc_insertion_point(field_get:DriverMessages.gps.altitude)
  return altitude_;
}
inline void gps::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.gps.altitude)
}

// -------------------------------------------------------------------

// imu

// required double q0 = 1;
inline bool imu::has_q0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void imu::set_has_q0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void imu::clear_has_q0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void imu::clear_q0() {
  q0_ = 0;
  clear_has_q0();
}
inline double imu::q0() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.q0)
  return q0_;
}
inline void imu::set_q0(double value) {
  set_has_q0();
  q0_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.imu.q0)
}

// required double q1 = 2;
inline bool imu::has_q1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void imu::set_has_q1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void imu::clear_has_q1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void imu::clear_q1() {
  q1_ = 0;
  clear_has_q1();
}
inline double imu::q1() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.q1)
  return q1_;
}
inline void imu::set_q1(double value) {
  set_has_q1();
  q1_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.imu.q1)
}

// required double q2 = 3;
inline bool imu::has_q2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void imu::set_has_q2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void imu::clear_has_q2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void imu::clear_q2() {
  q2_ = 0;
  clear_has_q2();
}
inline double imu::q2() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.q2)
  return q2_;
}
inline void imu::set_q2(double value) {
  set_has_q2();
  q2_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.imu.q2)
}

// required double q3 = 4;
inline bool imu::has_q3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void imu::set_has_q3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void imu::clear_has_q3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void imu::clear_q3() {
  q3_ = 0;
  clear_has_q3();
}
inline double imu::q3() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.q3)
  return q3_;
}
inline void imu::set_q3(double value) {
  set_has_q3();
  q3_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.imu.q3)
}

// -------------------------------------------------------------------

// control

// required double throttle = 1;
inline bool control::has_throttle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void control::set_has_throttle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void control::clear_has_throttle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void control::clear_throttle() {
  throttle_ = 0;
  clear_has_throttle();
}
inline double control::throttle() const {
  // @@protoc_insertion_point(field_get:DriverMessages.control.throttle)
  return throttle_;
}
inline void control::set_throttle(double value) {
  set_has_throttle();
  throttle_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.control.throttle)
}

// required double steering = 2;
inline bool control::has_steering() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void control::set_has_steering() {
  _has_bits_[0] |= 0x00000002u;
}
inline void control::clear_has_steering() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void control::clear_steering() {
  steering_ = 0;
  clear_has_steering();
}
inline double control::steering() const {
  // @@protoc_insertion_point(field_get:DriverMessages.control.steering)
  return steering_;
}
inline void control::set_steering(double value) {
  set_has_steering();
  steering_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.control.steering)
}

// required double braking = 3;
inline bool control::has_braking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void control::set_has_braking() {
  _has_bits_[0] |= 0x00000004u;
}
inline void control::clear_has_braking() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void control::clear_braking() {
  braking_ = 0;
  clear_has_braking();
}
inline double control::braking() const {
  // @@protoc_insertion_point(field_get:DriverMessages.control.braking)
  return braking_;
}
inline void control::set_braking(double value) {
  set_has_braking();
  braking_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.control.braking)
}

// -------------------------------------------------------------------

// time

// required double t = 1;
inline bool time::has_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void time::set_has_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void time::clear_has_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void time::clear_t() {
  t_ = 0;
  clear_has_t();
}
inline double time::t() const {
  // @@protoc_insertion_point(field_get:DriverMessages.time.t)
  return t_;
}
inline void time::set_t(double value) {
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.time.t)
}

// -------------------------------------------------------------------

// light

// required double xpos = 1;
inline bool light::has_xpos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void light::set_has_xpos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void light::clear_has_xpos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void light::clear_xpos() {
  xpos_ = 0;
  clear_has_xpos();
}
inline double light::xpos() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.xpos)
  return xpos_;
}
inline void light::set_xpos(double value) {
  set_has_xpos();
  xpos_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.xpos)
}

// required double ypos = 2;
inline bool light::has_ypos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void light::set_has_ypos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void light::clear_has_ypos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void light::clear_ypos() {
  ypos_ = 0;
  clear_has_ypos();
}
inline double light::ypos() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.ypos)
  return ypos_;
}
inline void light::set_ypos(double value) {
  set_has_ypos();
  ypos_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.ypos)
}

// required double xdir = 3;
inline bool light::has_xdir() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void light::set_has_xdir() {
  _has_bits_[0] |= 0x00000004u;
}
inline void light::clear_has_xdir() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void light::clear_xdir() {
  xdir_ = 0;
  clear_has_xdir();
}
inline double light::xdir() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.xdir)
  return xdir_;
}
inline void light::set_xdir(double value) {
  set_has_xdir();
  xdir_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.xdir)
}

// required double ydir = 4;
inline bool light::has_ydir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void light::set_has_ydir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void light::clear_has_ydir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void light::clear_ydir() {
  ydir_ = 0;
  clear_has_ydir();
}
inline double light::ydir() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.ydir)
  return ydir_;
}
inline void light::set_ydir(double value) {
  set_has_ydir();
  ydir_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.ydir)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DriverMessages

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_DriverMessages_2eproto__INCLUDED
