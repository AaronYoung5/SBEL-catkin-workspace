// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DriverMessages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "auto_custom_driver/DriverMessages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace DriverMessages {

namespace {

const ::google::protobuf::Descriptor* lidar_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  lidar_reflection_ = NULL;
const ::google::protobuf::Descriptor* gps_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  gps_reflection_ = NULL;
const ::google::protobuf::Descriptor* imu_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  imu_reflection_ = NULL;
const ::google::protobuf::Descriptor* control_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  control_reflection_ = NULL;
const ::google::protobuf::Descriptor* time_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  time_reflection_ = NULL;
const ::google::protobuf::Descriptor* light_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  light_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_DriverMessages_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_DriverMessages_2eproto() {
  protobuf_AddDesc_DriverMessages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "DriverMessages.proto");
  GOOGLE_CHECK(file != NULL);
  lidar_descriptor_ = file->message_type(0);
  static const int lidar_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(lidar, data_),
  };
  lidar_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      lidar_descriptor_,
      lidar::default_instance_,
      lidar_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(lidar, _has_bits_[0]),
      -1,
      -1,
      sizeof(lidar),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(lidar, _internal_metadata_),
      -1);
  gps_descriptor_ = file->message_type(1);
  static const int gps_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gps, longitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gps, latitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gps, altitude_),
  };
  gps_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      gps_descriptor_,
      gps::default_instance_,
      gps_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gps, _has_bits_[0]),
      -1,
      -1,
      sizeof(gps),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(gps, _internal_metadata_),
      -1);
  imu_descriptor_ = file->message_type(2);
  static const int imu_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(imu, q0_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(imu, q1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(imu, q2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(imu, q3_),
  };
  imu_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      imu_descriptor_,
      imu::default_instance_,
      imu_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(imu, _has_bits_[0]),
      -1,
      -1,
      sizeof(imu),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(imu, _internal_metadata_),
      -1);
  control_descriptor_ = file->message_type(3);
  static const int control_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(control, throttle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(control, steering_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(control, braking_),
  };
  control_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      control_descriptor_,
      control::default_instance_,
      control_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(control, _has_bits_[0]),
      -1,
      -1,
      sizeof(control),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(control, _internal_metadata_),
      -1);
  time_descriptor_ = file->message_type(4);
  static const int time_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(time, t_),
  };
  time_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      time_descriptor_,
      time::default_instance_,
      time_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(time, _has_bits_[0]),
      -1,
      -1,
      sizeof(time),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(time, _internal_metadata_),
      -1);
  light_descriptor_ = file->message_type(5);
  static const int light_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(light, xpos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(light, ypos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(light, xdir_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(light, ydir_),
  };
  light_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      light_descriptor_,
      light::default_instance_,
      light_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(light, _has_bits_[0]),
      -1,
      -1,
      sizeof(light),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(light, _internal_metadata_),
      -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_DriverMessages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      lidar_descriptor_, &lidar::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      gps_descriptor_, &gps::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      imu_descriptor_, &imu::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      control_descriptor_, &control::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      time_descriptor_, &time::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      light_descriptor_, &light::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_DriverMessages_2eproto() {
  delete lidar::default_instance_;
  delete lidar_reflection_;
  delete gps::default_instance_;
  delete gps_reflection_;
  delete imu::default_instance_;
  delete imu_reflection_;
  delete control::default_instance_;
  delete control_reflection_;
  delete time::default_instance_;
  delete time_reflection_;
  delete light::default_instance_;
  delete light_reflection_;
}

void protobuf_AddDesc_DriverMessages_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_DriverMessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024DriverMessages.proto\022\016DriverMessages\"\025"
    "\n\005lidar\022\014\n\004data\030\001 \003(\001\"<\n\003gps\022\021\n\tlongitud"
    "e\030\001 \002(\001\022\020\n\010latitude\030\002 \002(\001\022\020\n\010altitude\030\003 "
    "\002(\001\"5\n\003imu\022\n\n\002q0\030\001 \002(\001\022\n\n\002q1\030\002 \002(\001\022\n\n\002q2"
    "\030\003 \002(\001\022\n\n\002q3\030\004 \002(\001\">\n\007control\022\020\n\010throttl"
    "e\030\001 \002(\001\022\020\n\010steering\030\002 \002(\001\022\017\n\007braking\030\003 \002"
    "(\001\"\021\n\004time\022\t\n\001t\030\001 \002(\001\"\?\n\005light\022\014\n\004xpos\030\001"
    " \002(\001\022\014\n\004ypos\030\002 \002(\001\022\014\n\004xdir\030\003 \002(\001\022\014\n\004ydir"
    "\030\004 \002(\001", 326);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "DriverMessages.proto", &protobuf_RegisterTypes);
  lidar::default_instance_ = new lidar();
  gps::default_instance_ = new gps();
  imu::default_instance_ = new imu();
  control::default_instance_ = new control();
  time::default_instance_ = new time();
  light::default_instance_ = new light();
  lidar::default_instance_->InitAsDefaultInstance();
  gps::default_instance_->InitAsDefaultInstance();
  imu::default_instance_->InitAsDefaultInstance();
  control::default_instance_->InitAsDefaultInstance();
  time::default_instance_->InitAsDefaultInstance();
  light::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_DriverMessages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_DriverMessages_2eproto {
  StaticDescriptorInitializer_DriverMessages_2eproto() {
    protobuf_AddDesc_DriverMessages_2eproto();
  }
} static_descriptor_initializer_DriverMessages_2eproto_;

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int lidar::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

lidar::lidar()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DriverMessages.lidar)
}

void lidar::InitAsDefaultInstance() {
}

lidar::lidar(const lidar& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DriverMessages.lidar)
}

void lidar::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

lidar::~lidar() {
  // @@protoc_insertion_point(destructor:DriverMessages.lidar)
  SharedDtor();
}

void lidar::SharedDtor() {
  if (this != default_instance_) {
  }
}

void lidar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* lidar::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return lidar_descriptor_;
}

const lidar& lidar::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_DriverMessages_2eproto();
  return *default_instance_;
}

lidar* lidar::default_instance_ = NULL;

lidar* lidar::New(::google::protobuf::Arena* arena) const {
  lidar* n = new lidar;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void lidar::Clear() {
// @@protoc_insertion_point(message_clear_start:DriverMessages.lidar)
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool lidar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DriverMessages.lidar)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double data = 1;
      case 1: {
        if (tag == 9) {
         parse_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9, input, this->mutable_data())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_data())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(9)) goto parse_data;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DriverMessages.lidar)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DriverMessages.lidar)
  return false;
#undef DO_
}

void lidar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DriverMessages.lidar)
  // repeated double data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->data(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DriverMessages.lidar)
}

::google::protobuf::uint8* lidar::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DriverMessages.lidar)
  // repeated double data = 1;
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(1, this->data(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DriverMessages.lidar)
  return target;
}

int lidar::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DriverMessages.lidar)
  int total_size = 0;

  // repeated double data = 1;
  {
    int data_size = 0;
    data_size = 8 * this->data_size();
    total_size += 1 * this->data_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void lidar::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DriverMessages.lidar)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const lidar* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const lidar>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DriverMessages.lidar)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DriverMessages.lidar)
    MergeFrom(*source);
  }
}

void lidar::MergeFrom(const lidar& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DriverMessages.lidar)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  data_.MergeFrom(from.data_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void lidar::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DriverMessages.lidar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void lidar::CopyFrom(const lidar& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DriverMessages.lidar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool lidar::IsInitialized() const {

  return true;
}

void lidar::Swap(lidar* other) {
  if (other == this) return;
  InternalSwap(other);
}
void lidar::InternalSwap(lidar* other) {
  data_.UnsafeArenaSwap(&other->data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata lidar::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = lidar_descriptor_;
  metadata.reflection = lidar_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// lidar

// repeated double data = 1;
int lidar::data_size() const {
  return data_.size();
}
void lidar::clear_data() {
  data_.Clear();
}
 double lidar::data(int index) const {
  // @@protoc_insertion_point(field_get:DriverMessages.lidar.data)
  return data_.Get(index);
}
 void lidar::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:DriverMessages.lidar.data)
}
 void lidar::add_data(double value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:DriverMessages.lidar.data)
}
 const ::google::protobuf::RepeatedField< double >&
lidar::data() const {
  // @@protoc_insertion_point(field_list:DriverMessages.lidar.data)
  return data_;
}
 ::google::protobuf::RepeatedField< double >*
lidar::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:DriverMessages.lidar.data)
  return &data_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int gps::kLongitudeFieldNumber;
const int gps::kLatitudeFieldNumber;
const int gps::kAltitudeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

gps::gps()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DriverMessages.gps)
}

void gps::InitAsDefaultInstance() {
}

gps::gps(const gps& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DriverMessages.gps)
}

void gps::SharedCtor() {
  _cached_size_ = 0;
  longitude_ = 0;
  latitude_ = 0;
  altitude_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

gps::~gps() {
  // @@protoc_insertion_point(destructor:DriverMessages.gps)
  SharedDtor();
}

void gps::SharedDtor() {
  if (this != default_instance_) {
  }
}

void gps::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* gps::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return gps_descriptor_;
}

const gps& gps::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_DriverMessages_2eproto();
  return *default_instance_;
}

gps* gps::default_instance_ = NULL;

gps* gps::New(::google::protobuf::Arena* arena) const {
  gps* n = new gps;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void gps::Clear() {
// @@protoc_insertion_point(message_clear_start:DriverMessages.gps)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(gps, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<gps*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(longitude_, altitude_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool gps::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DriverMessages.gps)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double longitude = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &longitude_)));
          set_has_longitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_latitude;
        break;
      }

      // required double latitude = 2;
      case 2: {
        if (tag == 17) {
         parse_latitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &latitude_)));
          set_has_latitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_altitude;
        break;
      }

      // required double altitude = 3;
      case 3: {
        if (tag == 25) {
         parse_altitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &altitude_)));
          set_has_altitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DriverMessages.gps)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DriverMessages.gps)
  return false;
#undef DO_
}

void gps::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DriverMessages.gps)
  // required double longitude = 1;
  if (has_longitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->longitude(), output);
  }

  // required double latitude = 2;
  if (has_latitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->latitude(), output);
  }

  // required double altitude = 3;
  if (has_altitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->altitude(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DriverMessages.gps)
}

::google::protobuf::uint8* gps::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DriverMessages.gps)
  // required double longitude = 1;
  if (has_longitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->longitude(), target);
  }

  // required double latitude = 2;
  if (has_latitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->latitude(), target);
  }

  // required double altitude = 3;
  if (has_altitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->altitude(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DriverMessages.gps)
  return target;
}

int gps::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DriverMessages.gps)
  int total_size = 0;

  if (has_longitude()) {
    // required double longitude = 1;
    total_size += 1 + 8;
  }

  if (has_latitude()) {
    // required double latitude = 2;
    total_size += 1 + 8;
  }

  if (has_altitude()) {
    // required double altitude = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
int gps::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DriverMessages.gps)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double longitude = 1;
    total_size += 1 + 8;

    // required double latitude = 2;
    total_size += 1 + 8;

    // required double altitude = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void gps::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DriverMessages.gps)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const gps* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const gps>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DriverMessages.gps)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DriverMessages.gps)
    MergeFrom(*source);
  }
}

void gps::MergeFrom(const gps& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DriverMessages.gps)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_longitude()) {
      set_longitude(from.longitude());
    }
    if (from.has_latitude()) {
      set_latitude(from.latitude());
    }
    if (from.has_altitude()) {
      set_altitude(from.altitude());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void gps::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DriverMessages.gps)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void gps::CopyFrom(const gps& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DriverMessages.gps)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool gps::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void gps::Swap(gps* other) {
  if (other == this) return;
  InternalSwap(other);
}
void gps::InternalSwap(gps* other) {
  std::swap(longitude_, other->longitude_);
  std::swap(latitude_, other->latitude_);
  std::swap(altitude_, other->altitude_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata gps::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = gps_descriptor_;
  metadata.reflection = gps_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// gps

// required double longitude = 1;
bool gps::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void gps::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
void gps::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
void gps::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
 double gps::longitude() const {
  // @@protoc_insertion_point(field_get:DriverMessages.gps.longitude)
  return longitude_;
}
 void gps::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.gps.longitude)
}

// required double latitude = 2;
bool gps::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void gps::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
void gps::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
void gps::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
 double gps::latitude() const {
  // @@protoc_insertion_point(field_get:DriverMessages.gps.latitude)
  return latitude_;
}
 void gps::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.gps.latitude)
}

// required double altitude = 3;
bool gps::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void gps::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
void gps::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
void gps::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
 double gps::altitude() const {
  // @@protoc_insertion_point(field_get:DriverMessages.gps.altitude)
  return altitude_;
}
 void gps::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.gps.altitude)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int imu::kQ0FieldNumber;
const int imu::kQ1FieldNumber;
const int imu::kQ2FieldNumber;
const int imu::kQ3FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

imu::imu()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DriverMessages.imu)
}

void imu::InitAsDefaultInstance() {
}

imu::imu(const imu& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DriverMessages.imu)
}

void imu::SharedCtor() {
  _cached_size_ = 0;
  q0_ = 0;
  q1_ = 0;
  q2_ = 0;
  q3_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

imu::~imu() {
  // @@protoc_insertion_point(destructor:DriverMessages.imu)
  SharedDtor();
}

void imu::SharedDtor() {
  if (this != default_instance_) {
  }
}

void imu::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* imu::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return imu_descriptor_;
}

const imu& imu::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_DriverMessages_2eproto();
  return *default_instance_;
}

imu* imu::default_instance_ = NULL;

imu* imu::New(::google::protobuf::Arena* arena) const {
  imu* n = new imu;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void imu::Clear() {
// @@protoc_insertion_point(message_clear_start:DriverMessages.imu)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(imu, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<imu*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(q0_, q3_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool imu::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DriverMessages.imu)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double q0 = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &q0_)));
          set_has_q0();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_q1;
        break;
      }

      // required double q1 = 2;
      case 2: {
        if (tag == 17) {
         parse_q1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &q1_)));
          set_has_q1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_q2;
        break;
      }

      // required double q2 = 3;
      case 3: {
        if (tag == 25) {
         parse_q2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &q2_)));
          set_has_q2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_q3;
        break;
      }

      // required double q3 = 4;
      case 4: {
        if (tag == 33) {
         parse_q3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &q3_)));
          set_has_q3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DriverMessages.imu)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DriverMessages.imu)
  return false;
#undef DO_
}

void imu::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DriverMessages.imu)
  // required double q0 = 1;
  if (has_q0()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->q0(), output);
  }

  // required double q1 = 2;
  if (has_q1()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->q1(), output);
  }

  // required double q2 = 3;
  if (has_q2()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->q2(), output);
  }

  // required double q3 = 4;
  if (has_q3()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->q3(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DriverMessages.imu)
}

::google::protobuf::uint8* imu::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DriverMessages.imu)
  // required double q0 = 1;
  if (has_q0()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->q0(), target);
  }

  // required double q1 = 2;
  if (has_q1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->q1(), target);
  }

  // required double q2 = 3;
  if (has_q2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->q2(), target);
  }

  // required double q3 = 4;
  if (has_q3()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->q3(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DriverMessages.imu)
  return target;
}

int imu::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DriverMessages.imu)
  int total_size = 0;

  if (has_q0()) {
    // required double q0 = 1;
    total_size += 1 + 8;
  }

  if (has_q1()) {
    // required double q1 = 2;
    total_size += 1 + 8;
  }

  if (has_q2()) {
    // required double q2 = 3;
    total_size += 1 + 8;
  }

  if (has_q3()) {
    // required double q3 = 4;
    total_size += 1 + 8;
  }

  return total_size;
}
int imu::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DriverMessages.imu)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double q0 = 1;
    total_size += 1 + 8;

    // required double q1 = 2;
    total_size += 1 + 8;

    // required double q2 = 3;
    total_size += 1 + 8;

    // required double q3 = 4;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void imu::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DriverMessages.imu)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const imu* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const imu>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DriverMessages.imu)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DriverMessages.imu)
    MergeFrom(*source);
  }
}

void imu::MergeFrom(const imu& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DriverMessages.imu)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_q0()) {
      set_q0(from.q0());
    }
    if (from.has_q1()) {
      set_q1(from.q1());
    }
    if (from.has_q2()) {
      set_q2(from.q2());
    }
    if (from.has_q3()) {
      set_q3(from.q3());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void imu::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DriverMessages.imu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void imu::CopyFrom(const imu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DriverMessages.imu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool imu::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void imu::Swap(imu* other) {
  if (other == this) return;
  InternalSwap(other);
}
void imu::InternalSwap(imu* other) {
  std::swap(q0_, other->q0_);
  std::swap(q1_, other->q1_);
  std::swap(q2_, other->q2_);
  std::swap(q3_, other->q3_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata imu::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = imu_descriptor_;
  metadata.reflection = imu_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// imu

// required double q0 = 1;
bool imu::has_q0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void imu::set_has_q0() {
  _has_bits_[0] |= 0x00000001u;
}
void imu::clear_has_q0() {
  _has_bits_[0] &= ~0x00000001u;
}
void imu::clear_q0() {
  q0_ = 0;
  clear_has_q0();
}
 double imu::q0() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.q0)
  return q0_;
}
 void imu::set_q0(double value) {
  set_has_q0();
  q0_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.imu.q0)
}

// required double q1 = 2;
bool imu::has_q1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void imu::set_has_q1() {
  _has_bits_[0] |= 0x00000002u;
}
void imu::clear_has_q1() {
  _has_bits_[0] &= ~0x00000002u;
}
void imu::clear_q1() {
  q1_ = 0;
  clear_has_q1();
}
 double imu::q1() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.q1)
  return q1_;
}
 void imu::set_q1(double value) {
  set_has_q1();
  q1_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.imu.q1)
}

// required double q2 = 3;
bool imu::has_q2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void imu::set_has_q2() {
  _has_bits_[0] |= 0x00000004u;
}
void imu::clear_has_q2() {
  _has_bits_[0] &= ~0x00000004u;
}
void imu::clear_q2() {
  q2_ = 0;
  clear_has_q2();
}
 double imu::q2() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.q2)
  return q2_;
}
 void imu::set_q2(double value) {
  set_has_q2();
  q2_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.imu.q2)
}

// required double q3 = 4;
bool imu::has_q3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void imu::set_has_q3() {
  _has_bits_[0] |= 0x00000008u;
}
void imu::clear_has_q3() {
  _has_bits_[0] &= ~0x00000008u;
}
void imu::clear_q3() {
  q3_ = 0;
  clear_has_q3();
}
 double imu::q3() const {
  // @@protoc_insertion_point(field_get:DriverMessages.imu.q3)
  return q3_;
}
 void imu::set_q3(double value) {
  set_has_q3();
  q3_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.imu.q3)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int control::kThrottleFieldNumber;
const int control::kSteeringFieldNumber;
const int control::kBrakingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

control::control()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DriverMessages.control)
}

void control::InitAsDefaultInstance() {
}

control::control(const control& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DriverMessages.control)
}

void control::SharedCtor() {
  _cached_size_ = 0;
  throttle_ = 0;
  steering_ = 0;
  braking_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

control::~control() {
  // @@protoc_insertion_point(destructor:DriverMessages.control)
  SharedDtor();
}

void control::SharedDtor() {
  if (this != default_instance_) {
  }
}

void control::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* control::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return control_descriptor_;
}

const control& control::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_DriverMessages_2eproto();
  return *default_instance_;
}

control* control::default_instance_ = NULL;

control* control::New(::google::protobuf::Arena* arena) const {
  control* n = new control;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void control::Clear() {
// @@protoc_insertion_point(message_clear_start:DriverMessages.control)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(control, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<control*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(throttle_, braking_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool control::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DriverMessages.control)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double throttle = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &throttle_)));
          set_has_throttle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_steering;
        break;
      }

      // required double steering = 2;
      case 2: {
        if (tag == 17) {
         parse_steering:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &steering_)));
          set_has_steering();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_braking;
        break;
      }

      // required double braking = 3;
      case 3: {
        if (tag == 25) {
         parse_braking:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &braking_)));
          set_has_braking();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DriverMessages.control)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DriverMessages.control)
  return false;
#undef DO_
}

void control::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DriverMessages.control)
  // required double throttle = 1;
  if (has_throttle()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->throttle(), output);
  }

  // required double steering = 2;
  if (has_steering()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->steering(), output);
  }

  // required double braking = 3;
  if (has_braking()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->braking(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DriverMessages.control)
}

::google::protobuf::uint8* control::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DriverMessages.control)
  // required double throttle = 1;
  if (has_throttle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->throttle(), target);
  }

  // required double steering = 2;
  if (has_steering()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->steering(), target);
  }

  // required double braking = 3;
  if (has_braking()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->braking(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DriverMessages.control)
  return target;
}

int control::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DriverMessages.control)
  int total_size = 0;

  if (has_throttle()) {
    // required double throttle = 1;
    total_size += 1 + 8;
  }

  if (has_steering()) {
    // required double steering = 2;
    total_size += 1 + 8;
  }

  if (has_braking()) {
    // required double braking = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
int control::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DriverMessages.control)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double throttle = 1;
    total_size += 1 + 8;

    // required double steering = 2;
    total_size += 1 + 8;

    // required double braking = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void control::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DriverMessages.control)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const control* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const control>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DriverMessages.control)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DriverMessages.control)
    MergeFrom(*source);
  }
}

void control::MergeFrom(const control& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DriverMessages.control)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_throttle()) {
      set_throttle(from.throttle());
    }
    if (from.has_steering()) {
      set_steering(from.steering());
    }
    if (from.has_braking()) {
      set_braking(from.braking());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void control::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DriverMessages.control)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void control::CopyFrom(const control& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DriverMessages.control)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool control::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void control::Swap(control* other) {
  if (other == this) return;
  InternalSwap(other);
}
void control::InternalSwap(control* other) {
  std::swap(throttle_, other->throttle_);
  std::swap(steering_, other->steering_);
  std::swap(braking_, other->braking_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata control::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = control_descriptor_;
  metadata.reflection = control_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// control

// required double throttle = 1;
bool control::has_throttle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void control::set_has_throttle() {
  _has_bits_[0] |= 0x00000001u;
}
void control::clear_has_throttle() {
  _has_bits_[0] &= ~0x00000001u;
}
void control::clear_throttle() {
  throttle_ = 0;
  clear_has_throttle();
}
 double control::throttle() const {
  // @@protoc_insertion_point(field_get:DriverMessages.control.throttle)
  return throttle_;
}
 void control::set_throttle(double value) {
  set_has_throttle();
  throttle_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.control.throttle)
}

// required double steering = 2;
bool control::has_steering() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void control::set_has_steering() {
  _has_bits_[0] |= 0x00000002u;
}
void control::clear_has_steering() {
  _has_bits_[0] &= ~0x00000002u;
}
void control::clear_steering() {
  steering_ = 0;
  clear_has_steering();
}
 double control::steering() const {
  // @@protoc_insertion_point(field_get:DriverMessages.control.steering)
  return steering_;
}
 void control::set_steering(double value) {
  set_has_steering();
  steering_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.control.steering)
}

// required double braking = 3;
bool control::has_braking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void control::set_has_braking() {
  _has_bits_[0] |= 0x00000004u;
}
void control::clear_has_braking() {
  _has_bits_[0] &= ~0x00000004u;
}
void control::clear_braking() {
  braking_ = 0;
  clear_has_braking();
}
 double control::braking() const {
  // @@protoc_insertion_point(field_get:DriverMessages.control.braking)
  return braking_;
}
 void control::set_braking(double value) {
  set_has_braking();
  braking_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.control.braking)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int time::kTFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

time::time()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DriverMessages.time)
}

void time::InitAsDefaultInstance() {
}

time::time(const time& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DriverMessages.time)
}

void time::SharedCtor() {
  _cached_size_ = 0;
  t_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

time::~time() {
  // @@protoc_insertion_point(destructor:DriverMessages.time)
  SharedDtor();
}

void time::SharedDtor() {
  if (this != default_instance_) {
  }
}

void time::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* time::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return time_descriptor_;
}

const time& time::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_DriverMessages_2eproto();
  return *default_instance_;
}

time* time::default_instance_ = NULL;

time* time::New(::google::protobuf::Arena* arena) const {
  time* n = new time;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void time::Clear() {
// @@protoc_insertion_point(message_clear_start:DriverMessages.time)
  t_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool time::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DriverMessages.time)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double t = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &t_)));
          set_has_t();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DriverMessages.time)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DriverMessages.time)
  return false;
#undef DO_
}

void time::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DriverMessages.time)
  // required double t = 1;
  if (has_t()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->t(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DriverMessages.time)
}

::google::protobuf::uint8* time::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DriverMessages.time)
  // required double t = 1;
  if (has_t()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->t(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DriverMessages.time)
  return target;
}

int time::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DriverMessages.time)
  int total_size = 0;

  // required double t = 1;
  if (has_t()) {
    total_size += 1 + 8;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void time::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DriverMessages.time)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const time* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const time>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DriverMessages.time)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DriverMessages.time)
    MergeFrom(*source);
  }
}

void time::MergeFrom(const time& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DriverMessages.time)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_t()) {
      set_t(from.t());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void time::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DriverMessages.time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void time::CopyFrom(const time& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DriverMessages.time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool time::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void time::Swap(time* other) {
  if (other == this) return;
  InternalSwap(other);
}
void time::InternalSwap(time* other) {
  std::swap(t_, other->t_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata time::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = time_descriptor_;
  metadata.reflection = time_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// time

// required double t = 1;
bool time::has_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void time::set_has_t() {
  _has_bits_[0] |= 0x00000001u;
}
void time::clear_has_t() {
  _has_bits_[0] &= ~0x00000001u;
}
void time::clear_t() {
  t_ = 0;
  clear_has_t();
}
 double time::t() const {
  // @@protoc_insertion_point(field_get:DriverMessages.time.t)
  return t_;
}
 void time::set_t(double value) {
  set_has_t();
  t_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.time.t)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int light::kXposFieldNumber;
const int light::kYposFieldNumber;
const int light::kXdirFieldNumber;
const int light::kYdirFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

light::light()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DriverMessages.light)
}

void light::InitAsDefaultInstance() {
}

light::light(const light& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DriverMessages.light)
}

void light::SharedCtor() {
  _cached_size_ = 0;
  xpos_ = 0;
  ypos_ = 0;
  xdir_ = 0;
  ydir_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

light::~light() {
  // @@protoc_insertion_point(destructor:DriverMessages.light)
  SharedDtor();
}

void light::SharedDtor() {
  if (this != default_instance_) {
  }
}

void light::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* light::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return light_descriptor_;
}

const light& light::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_DriverMessages_2eproto();
  return *default_instance_;
}

light* light::default_instance_ = NULL;

light* light::New(::google::protobuf::Arena* arena) const {
  light* n = new light;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void light::Clear() {
// @@protoc_insertion_point(message_clear_start:DriverMessages.light)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(light, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<light*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(xpos_, ydir_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool light::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DriverMessages.light)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double xpos = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &xpos_)));
          set_has_xpos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_ypos;
        break;
      }

      // required double ypos = 2;
      case 2: {
        if (tag == 17) {
         parse_ypos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ypos_)));
          set_has_ypos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_xdir;
        break;
      }

      // required double xdir = 3;
      case 3: {
        if (tag == 25) {
         parse_xdir:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &xdir_)));
          set_has_xdir();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_ydir;
        break;
      }

      // required double ydir = 4;
      case 4: {
        if (tag == 33) {
         parse_ydir:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ydir_)));
          set_has_ydir();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DriverMessages.light)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DriverMessages.light)
  return false;
#undef DO_
}

void light::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DriverMessages.light)
  // required double xpos = 1;
  if (has_xpos()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->xpos(), output);
  }

  // required double ypos = 2;
  if (has_ypos()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ypos(), output);
  }

  // required double xdir = 3;
  if (has_xdir()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->xdir(), output);
  }

  // required double ydir = 4;
  if (has_ydir()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->ydir(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DriverMessages.light)
}

::google::protobuf::uint8* light::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DriverMessages.light)
  // required double xpos = 1;
  if (has_xpos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->xpos(), target);
  }

  // required double ypos = 2;
  if (has_ypos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->ypos(), target);
  }

  // required double xdir = 3;
  if (has_xdir()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->xdir(), target);
  }

  // required double ydir = 4;
  if (has_ydir()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->ydir(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DriverMessages.light)
  return target;
}

int light::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DriverMessages.light)
  int total_size = 0;

  if (has_xpos()) {
    // required double xpos = 1;
    total_size += 1 + 8;
  }

  if (has_ypos()) {
    // required double ypos = 2;
    total_size += 1 + 8;
  }

  if (has_xdir()) {
    // required double xdir = 3;
    total_size += 1 + 8;
  }

  if (has_ydir()) {
    // required double ydir = 4;
    total_size += 1 + 8;
  }

  return total_size;
}
int light::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DriverMessages.light)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double xpos = 1;
    total_size += 1 + 8;

    // required double ypos = 2;
    total_size += 1 + 8;

    // required double xdir = 3;
    total_size += 1 + 8;

    // required double ydir = 4;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void light::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DriverMessages.light)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const light* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const light>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DriverMessages.light)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DriverMessages.light)
    MergeFrom(*source);
  }
}

void light::MergeFrom(const light& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DriverMessages.light)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_xpos()) {
      set_xpos(from.xpos());
    }
    if (from.has_ypos()) {
      set_ypos(from.ypos());
    }
    if (from.has_xdir()) {
      set_xdir(from.xdir());
    }
    if (from.has_ydir()) {
      set_ydir(from.ydir());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void light::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DriverMessages.light)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void light::CopyFrom(const light& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DriverMessages.light)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool light::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void light::Swap(light* other) {
  if (other == this) return;
  InternalSwap(other);
}
void light::InternalSwap(light* other) {
  std::swap(xpos_, other->xpos_);
  std::swap(ypos_, other->ypos_);
  std::swap(xdir_, other->xdir_);
  std::swap(ydir_, other->ydir_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata light::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = light_descriptor_;
  metadata.reflection = light_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// light

// required double xpos = 1;
bool light::has_xpos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void light::set_has_xpos() {
  _has_bits_[0] |= 0x00000001u;
}
void light::clear_has_xpos() {
  _has_bits_[0] &= ~0x00000001u;
}
void light::clear_xpos() {
  xpos_ = 0;
  clear_has_xpos();
}
 double light::xpos() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.xpos)
  return xpos_;
}
 void light::set_xpos(double value) {
  set_has_xpos();
  xpos_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.xpos)
}

// required double ypos = 2;
bool light::has_ypos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void light::set_has_ypos() {
  _has_bits_[0] |= 0x00000002u;
}
void light::clear_has_ypos() {
  _has_bits_[0] &= ~0x00000002u;
}
void light::clear_ypos() {
  ypos_ = 0;
  clear_has_ypos();
}
 double light::ypos() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.ypos)
  return ypos_;
}
 void light::set_ypos(double value) {
  set_has_ypos();
  ypos_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.ypos)
}

// required double xdir = 3;
bool light::has_xdir() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void light::set_has_xdir() {
  _has_bits_[0] |= 0x00000004u;
}
void light::clear_has_xdir() {
  _has_bits_[0] &= ~0x00000004u;
}
void light::clear_xdir() {
  xdir_ = 0;
  clear_has_xdir();
}
 double light::xdir() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.xdir)
  return xdir_;
}
 void light::set_xdir(double value) {
  set_has_xdir();
  xdir_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.xdir)
}

// required double ydir = 4;
bool light::has_ydir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void light::set_has_ydir() {
  _has_bits_[0] |= 0x00000008u;
}
void light::clear_has_ydir() {
  _has_bits_[0] &= ~0x00000008u;
}
void light::clear_ydir() {
  ydir_ = 0;
  clear_has_ydir();
}
 double light::ydir() const {
  // @@protoc_insertion_point(field_get:DriverMessages.light.ydir)
  return ydir_;
}
 void light::set_ydir(double value) {
  set_has_ydir();
  ydir_ = value;
  // @@protoc_insertion_point(field_set:DriverMessages.light.ydir)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace DriverMessages

// @@protoc_insertion_point(global_scope)
