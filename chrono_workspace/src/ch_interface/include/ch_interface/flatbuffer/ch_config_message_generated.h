// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHCONFIGMESSAGE_CHCONFIGMESSAGE_H_
#define FLATBUFFERS_GENERATED_CHCONFIGMESSAGE_CHCONFIGMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

namespace ChConfigMessage {

struct Message;

struct Sensor;

struct Camera;

struct Lidar;

struct GPS;

struct IMU;

enum Type {
  Type_NONE = 0,
  Type_Camera = 1,
  Type_Lidar = 2,
  Type_GPS = 3,
  Type_IMU = 4,
  Type_MIN = Type_NONE,
  Type_MAX = Type_IMU
};

inline const Type (&EnumValuesType())[5] {
  static const Type values[] = {
    Type_NONE,
    Type_Camera,
    Type_Lidar,
    Type_GPS,
    Type_IMU
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[] = {
    "NONE",
    "Camera",
    "Lidar",
    "GPS",
    "IMU",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_IMU) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<Camera> {
  static const Type enum_value = Type_Camera;
};

template<> struct TypeTraits<Lidar> {
  static const Type enum_value = Type_Lidar;
};

template<> struct TypeTraits<GPS> {
  static const Type enum_value = Type_GPS;
};

template<> struct TypeTraits<IMU> {
  static const Type enum_value = Type_IMU;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENSORS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Sensor>> *sensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Sensor>> *>(VT_SENSORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SENSORS) &&
           verifier.VerifyVector(sensors()) &&
           verifier.VerifyVectorOfTables(sensors()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sensor>>> sensors) {
    fbb_.AddOffset(Message::VT_SENSORS, sensors);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sensor>>> sensors = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_sensors(sensors);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Sensor>> *sensors = nullptr) {
  auto sensors__ = sensors ? _fbb.CreateVector<flatbuffers::Offset<Sensor>>(*sensors) : 0;
  return ChConfigMessage::CreateMessage(
      _fbb,
      sensors__);
}

struct Sensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENSOR_TYPE = 4,
    VT_SENSOR = 6,
    VT_ID = 8,
    VT_FREQ = 10,
    VT_OFFSET = 12
  };
  Type sensor_type() const {
    return static_cast<Type>(GetField<uint8_t>(VT_SENSOR_TYPE, 0));
  }
  const void *sensor() const {
    return GetPointer<const void *>(VT_SENSOR);
  }
  template<typename T> const T *sensor_as() const;
  const Camera *sensor_as_Camera() const {
    return sensor_type() == Type_Camera ? static_cast<const Camera *>(sensor()) : nullptr;
  }
  const Lidar *sensor_as_Lidar() const {
    return sensor_type() == Type_Lidar ? static_cast<const Lidar *>(sensor()) : nullptr;
  }
  const GPS *sensor_as_GPS() const {
    return sensor_type() == Type_GPS ? static_cast<const GPS *>(sensor()) : nullptr;
  }
  const IMU *sensor_as_IMU() const {
    return sensor_type() == Type_IMU ? static_cast<const IMU *>(sensor()) : nullptr;
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int32_t freq() const {
    return GetField<int32_t>(VT_FREQ, 0);
  }
  const flatbuffers::Vector<float> *offset() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_OFFSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SENSOR_TYPE) &&
           VerifyOffset(verifier, VT_SENSOR) &&
           VerifyType(verifier, sensor(), sensor_type()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int32_t>(verifier, VT_FREQ) &&
           VerifyOffset(verifier, VT_OFFSET) &&
           verifier.VerifyVector(offset()) &&
           verifier.EndTable();
  }
};

template<> inline const Camera *Sensor::sensor_as<Camera>() const {
  return sensor_as_Camera();
}

template<> inline const Lidar *Sensor::sensor_as<Lidar>() const {
  return sensor_as_Lidar();
}

template<> inline const GPS *Sensor::sensor_as<GPS>() const {
  return sensor_as_GPS();
}

template<> inline const IMU *Sensor::sensor_as<IMU>() const {
  return sensor_as_IMU();
}

struct SensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sensor_type(Type sensor_type) {
    fbb_.AddElement<uint8_t>(Sensor::VT_SENSOR_TYPE, static_cast<uint8_t>(sensor_type), 0);
  }
  void add_sensor(flatbuffers::Offset<void> sensor) {
    fbb_.AddOffset(Sensor::VT_SENSOR, sensor);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Sensor::VT_ID, id);
  }
  void add_freq(int32_t freq) {
    fbb_.AddElement<int32_t>(Sensor::VT_FREQ, freq, 0);
  }
  void add_offset(flatbuffers::Offset<flatbuffers::Vector<float>> offset) {
    fbb_.AddOffset(Sensor::VT_OFFSET, offset);
  }
  explicit SensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SensorBuilder &operator=(const SensorBuilder &);
  flatbuffers::Offset<Sensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sensor> CreateSensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type sensor_type = Type_NONE,
    flatbuffers::Offset<void> sensor = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int32_t freq = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> offset = 0) {
  SensorBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_freq(freq);
  builder_.add_id(id);
  builder_.add_sensor(sensor);
  builder_.add_sensor_type(sensor_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sensor> CreateSensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type sensor_type = Type_NONE,
    flatbuffers::Offset<void> sensor = 0,
    const char *id = nullptr,
    int32_t freq = 0,
    const std::vector<float> *offset = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto offset__ = offset ? _fbb.CreateVector<float>(*offset) : 0;
  return ChConfigMessage::CreateSensor(
      _fbb,
      sensor_type,
      sensor,
      id__,
      freq,
      offset__);
}

struct Camera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_WIDTH = 6
  };
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           verifier.EndTable();
  }
};

struct CameraBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(Camera::VT_HEIGHT, height, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Camera::VT_WIDTH, width, 0);
  }
  explicit CameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CameraBuilder &operator=(const CameraBuilder &);
  flatbuffers::Offset<Camera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Camera>(end);
    return o;
  }
};

inline flatbuffers::Offset<Camera> CreateCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0) {
  CameraBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_height(height);
  return builder_.Finish();
}

struct Lidar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LidarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LidarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LidarBuilder &operator=(const LidarBuilder &);
  flatbuffers::Offset<Lidar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lidar>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lidar> CreateLidar(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LidarBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GPS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GPSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GPSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GPSBuilder &operator=(const GPSBuilder &);
  flatbuffers::Offset<GPS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GPS>(end);
    return o;
  }
};

inline flatbuffers::Offset<GPS> CreateGPS(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GPSBuilder builder_(_fbb);
  return builder_.Finish();
}

struct IMU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct IMUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IMUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IMUBuilder &operator=(const IMUBuilder &);
  flatbuffers::Offset<IMU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IMU>(end);
    return o;
  }
};

inline flatbuffers::Offset<IMU> CreateIMU(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IMUBuilder builder_(_fbb);
  return builder_.Finish();
}

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Camera: {
      auto ptr = reinterpret_cast<const Camera *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Lidar: {
      auto ptr = reinterpret_cast<const Lidar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GPS: {
      auto ptr = reinterpret_cast<const GPS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_IMU: {
      auto ptr = reinterpret_cast<const IMU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace ChConfigMessage

#endif  // FLATBUFFERS_GENERATED_CHCONFIGMESSAGE_CHCONFIGMESSAGE_H_
