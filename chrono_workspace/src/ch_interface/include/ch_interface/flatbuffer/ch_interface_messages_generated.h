// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHINTERFACEMESSAGES_CHINTERFACEMESSAGE_H_
#define FLATBUFFERS_GENERATED_CHINTERFACEMESSAGES_CHINTERFACEMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

namespace ChInterfaceMessage {

<<<<<<< HEAD
=======
struct Messages;

>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
struct Message;

struct Camera;

struct Lidar;

struct GPS;

struct IMU;

struct Control;

struct Time;

struct Exit;

<<<<<<< HEAD
struct Config;

struct Transport;

=======
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
enum Type {
  Type_NONE = 0,
  Type_Camera = 1,
  Type_Lidar = 2,
  Type_GPS = 3,
  Type_IMU = 4,
  Type_Control = 5,
  Type_Time = 6,
  Type_Exit = 7,
<<<<<<< HEAD
  Type_Config = 8,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Config
};

inline const Type (&EnumValuesType())[9] {
=======
  Type_MIN = Type_NONE,
  Type_MAX = Type_Exit
};

inline const Type (&EnumValuesType())[8] {
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
  static const Type values[] = {
    Type_NONE,
    Type_Camera,
    Type_Lidar,
    Type_GPS,
    Type_IMU,
    Type_Control,
    Type_Time,
<<<<<<< HEAD
    Type_Exit,
    Type_Config
=======
    Type_Exit
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
  };
  return values;
}

inline const char * const *EnumNamesType() {
<<<<<<< HEAD
  static const char * const names[] = {
=======
  static const char * const names[9] = {
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
    "NONE",
    "Camera",
    "Lidar",
    "GPS",
    "IMU",
    "Control",
    "Time",
    "Exit",
<<<<<<< HEAD
    "Config",
=======
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
<<<<<<< HEAD
  if (e < Type_NONE || e > Type_Config) return "";
=======
  if (e < Type_NONE || e > Type_Exit) return "";
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

<<<<<<< HEAD
template<> struct TypeTraits<Camera> {
  static const Type enum_value = Type_Camera;
};

template<> struct TypeTraits<Lidar> {
  static const Type enum_value = Type_Lidar;
};

template<> struct TypeTraits<GPS> {
  static const Type enum_value = Type_GPS;
};

template<> struct TypeTraits<IMU> {
  static const Type enum_value = Type_IMU;
};

template<> struct TypeTraits<Control> {
  static const Type enum_value = Type_Control;
};

template<> struct TypeTraits<Time> {
  static const Type enum_value = Type_Time;
};

template<> struct TypeTraits<Exit> {
  static const Type enum_value = Type_Exit;
};

template<> struct TypeTraits<Config> {
  static const Type enum_value = Type_Config;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

=======
template<> struct TypeTraits<ChInterfaceMessage::Camera> {
  static const Type enum_value = Type_Camera;
};

template<> struct TypeTraits<ChInterfaceMessage::Lidar> {
  static const Type enum_value = Type_Lidar;
};

template<> struct TypeTraits<ChInterfaceMessage::GPS> {
  static const Type enum_value = Type_GPS;
};

template<> struct TypeTraits<ChInterfaceMessage::IMU> {
  static const Type enum_value = Type_IMU;
};

template<> struct TypeTraits<ChInterfaceMessage::Control> {
  static const Type enum_value = Type_Control;
};

template<> struct TypeTraits<ChInterfaceMessage::Time> {
  static const Type enum_value = Type_Time;
};

template<> struct TypeTraits<ChInterfaceMessage::Exit> {
  static const Type enum_value = Type_Exit;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Messages FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGES = 4,
    VT_TIME = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<ChInterfaceMessage::Message>> *messages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ChInterfaceMessage::Message>> *>(VT_MESSAGES);
  }
  const ChInterfaceMessage::Message *time() const {
    return GetPointer<const ChInterfaceMessage::Message *>(VT_TIME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGES) &&
           verifier.VerifyVector(messages()) &&
           verifier.VerifyVectorOfTables(messages()) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.VerifyTable(time()) &&
           verifier.EndTable();
  }
};

struct MessagesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChInterfaceMessage::Message>>> messages) {
    fbb_.AddOffset(Messages::VT_MESSAGES, messages);
  }
  void add_time(flatbuffers::Offset<ChInterfaceMessage::Message> time) {
    fbb_.AddOffset(Messages::VT_TIME, time);
  }
  explicit MessagesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessagesBuilder &operator=(const MessagesBuilder &);
  flatbuffers::Offset<Messages> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Messages>(end);
    return o;
  }
};

inline flatbuffers::Offset<Messages> CreateMessages(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChInterfaceMessage::Message>>> messages = 0,
    flatbuffers::Offset<ChInterfaceMessage::Message> time = 0) {
  MessagesBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_messages(messages);
  return builder_.Finish();
}

inline flatbuffers::Offset<Messages> CreateMessagesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ChInterfaceMessage::Message>> *messages = nullptr,
    flatbuffers::Offset<ChInterfaceMessage::Message> time = 0) {
  auto messages__ = messages ? _fbb.CreateVector<flatbuffers::Offset<ChInterfaceMessage::Message>>(*messages) : 0;
  return ChInterfaceMessage::CreateMessages(
      _fbb,
      messages__,
      time);
}

>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
<<<<<<< HEAD
    VT_TIME = 8,
    VT_ID = 10
  };
  Type message_type() const {
    return static_cast<Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
=======
    VT_ID = 8
  };
  ChInterfaceMessage::Type message_type() const {
    return static_cast<ChInterfaceMessage::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
<<<<<<< HEAD
  const Camera *message_as_Camera() const {
    return message_type() == Type_Camera ? static_cast<const Camera *>(message()) : nullptr;
  }
  const Lidar *message_as_Lidar() const {
    return message_type() == Type_Lidar ? static_cast<const Lidar *>(message()) : nullptr;
  }
  const GPS *message_as_GPS() const {
    return message_type() == Type_GPS ? static_cast<const GPS *>(message()) : nullptr;
  }
  const IMU *message_as_IMU() const {
    return message_type() == Type_IMU ? static_cast<const IMU *>(message()) : nullptr;
  }
  const Control *message_as_Control() const {
    return message_type() == Type_Control ? static_cast<const Control *>(message()) : nullptr;
  }
  const Time *message_as_Time() const {
    return message_type() == Type_Time ? static_cast<const Time *>(message()) : nullptr;
  }
  const Exit *message_as_Exit() const {
    return message_type() == Type_Exit ? static_cast<const Exit *>(message()) : nullptr;
  }
  const Config *message_as_Config() const {
    return message_type() == Type_Config ? static_cast<const Config *>(message()) : nullptr;
  }
  const Time *time() const {
    return GetPointer<const Time *>(VT_TIME);
=======
  const ChInterfaceMessage::Camera *message_as_Camera() const {
    return message_type() == ChInterfaceMessage::Type_Camera ? static_cast<const ChInterfaceMessage::Camera *>(message()) : nullptr;
  }
  const ChInterfaceMessage::Lidar *message_as_Lidar() const {
    return message_type() == ChInterfaceMessage::Type_Lidar ? static_cast<const ChInterfaceMessage::Lidar *>(message()) : nullptr;
  }
  const ChInterfaceMessage::GPS *message_as_GPS() const {
    return message_type() == ChInterfaceMessage::Type_GPS ? static_cast<const ChInterfaceMessage::GPS *>(message()) : nullptr;
  }
  const ChInterfaceMessage::IMU *message_as_IMU() const {
    return message_type() == ChInterfaceMessage::Type_IMU ? static_cast<const ChInterfaceMessage::IMU *>(message()) : nullptr;
  }
  const ChInterfaceMessage::Control *message_as_Control() const {
    return message_type() == ChInterfaceMessage::Type_Control ? static_cast<const ChInterfaceMessage::Control *>(message()) : nullptr;
  }
  const ChInterfaceMessage::Time *message_as_Time() const {
    return message_type() == ChInterfaceMessage::Type_Time ? static_cast<const ChInterfaceMessage::Time *>(message()) : nullptr;
  }
  const ChInterfaceMessage::Exit *message_as_Exit() const {
    return message_type() == ChInterfaceMessage::Type_Exit ? static_cast<const ChInterfaceMessage::Exit *>(message()) : nullptr;
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
<<<<<<< HEAD
           VerifyOffset(verifier, VT_TIME) &&
           verifier.VerifyTable(time()) &&
=======
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

<<<<<<< HEAD
template<> inline const Camera *Message::message_as<Camera>() const {
  return message_as_Camera();
}

template<> inline const Lidar *Message::message_as<Lidar>() const {
  return message_as_Lidar();
}

template<> inline const GPS *Message::message_as<GPS>() const {
  return message_as_GPS();
}

template<> inline const IMU *Message::message_as<IMU>() const {
  return message_as_IMU();
}

template<> inline const Control *Message::message_as<Control>() const {
  return message_as_Control();
}

template<> inline const Time *Message::message_as<Time>() const {
  return message_as_Time();
}

template<> inline const Exit *Message::message_as<Exit>() const {
  return message_as_Exit();
}

template<> inline const Config *Message::message_as<Config>() const {
  return message_as_Config();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Type message_type) {
=======
template<> inline const ChInterfaceMessage::Camera *Message::message_as<ChInterfaceMessage::Camera>() const {
  return message_as_Camera();
}

template<> inline const ChInterfaceMessage::Lidar *Message::message_as<ChInterfaceMessage::Lidar>() const {
  return message_as_Lidar();
}

template<> inline const ChInterfaceMessage::GPS *Message::message_as<ChInterfaceMessage::GPS>() const {
  return message_as_GPS();
}

template<> inline const ChInterfaceMessage::IMU *Message::message_as<ChInterfaceMessage::IMU>() const {
  return message_as_IMU();
}

template<> inline const ChInterfaceMessage::Control *Message::message_as<ChInterfaceMessage::Control>() const {
  return message_as_Control();
}

template<> inline const ChInterfaceMessage::Time *Message::message_as<ChInterfaceMessage::Time>() const {
  return message_as_Time();
}

template<> inline const ChInterfaceMessage::Exit *Message::message_as<ChInterfaceMessage::Exit>() const {
  return message_as_Exit();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(ChInterfaceMessage::Type message_type) {
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
<<<<<<< HEAD
  void add_time(flatbuffers::Offset<Time> time) {
    fbb_.AddOffset(Message::VT_TIME, time);
  }
=======
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Message::VT_ID, id);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
<<<<<<< HEAD
    Type message_type = Type_NONE,
    flatbuffers::Offset<void> message = 0,
    flatbuffers::Offset<Time> time = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_time(time);
=======
    ChInterfaceMessage::Type message_type = ChInterfaceMessage::Type_NONE,
    flatbuffers::Offset<void> message = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_id(id);
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
<<<<<<< HEAD
    Type message_type = Type_NONE,
    flatbuffers::Offset<void> message = 0,
    flatbuffers::Offset<Time> time = 0,
=======
    ChInterfaceMessage::Type message_type = ChInterfaceMessage::Type_NONE,
    flatbuffers::Offset<void> message = 0,
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return ChInterfaceMessage::CreateMessage(
      _fbb,
      message_type,
      message,
<<<<<<< HEAD
      time,
=======
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
      id__);
}

struct Camera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_WIDTH = 6,
    VT_BYTES_PER_PIXEL = 8,
    VT_DATA = 10
  };
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t bytes_per_pixel() const {
    return GetField<int32_t>(VT_BYTES_PER_PIXEL, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_BYTES_PER_PIXEL) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct CameraBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(Camera::VT_HEIGHT, height, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Camera::VT_WIDTH, width, 0);
  }
  void add_bytes_per_pixel(int32_t bytes_per_pixel) {
    fbb_.AddElement<int32_t>(Camera::VT_BYTES_PER_PIXEL, bytes_per_pixel, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Camera::VT_DATA, data);
  }
  explicit CameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CameraBuilder &operator=(const CameraBuilder &);
  flatbuffers::Offset<Camera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Camera>(end);
    return o;
  }
};

inline flatbuffers::Offset<Camera> CreateCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    int32_t bytes_per_pixel = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  CameraBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_bytes_per_pixel(bytes_per_pixel);
  builder_.add_width(width);
  builder_.add_height(height);
  return builder_.Finish();
}

inline flatbuffers::Offset<Camera> CreateCameraDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    int32_t bytes_per_pixel = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return ChInterfaceMessage::CreateCamera(
      _fbb,
      height,
      width,
      bytes_per_pixel,
      data__);
}

struct Lidar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LidarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LidarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LidarBuilder &operator=(const LidarBuilder &);
  flatbuffers::Offset<Lidar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lidar>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lidar> CreateLidar(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LidarBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GPS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GPSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GPSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GPSBuilder &operator=(const GPSBuilder &);
  flatbuffers::Offset<GPS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GPS>(end);
    return o;
  }
};

inline flatbuffers::Offset<GPS> CreateGPS(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GPSBuilder builder_(_fbb);
  return builder_.Finish();
}

struct IMU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct IMUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IMUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IMUBuilder &operator=(const IMUBuilder &);
  flatbuffers::Offset<IMU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IMU>(end);
    return o;
  }
};

inline flatbuffers::Offset<IMU> CreateIMU(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IMUBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Control FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
<<<<<<< HEAD
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
=======
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THROTTLE = 4,
    VT_STEERING = 6,
    VT_BRAKING = 8
  };
  float throttle() const {
    return GetField<float>(VT_THROTTLE, 0.0f);
  }
  float steering() const {
    return GetField<float>(VT_STEERING, 0.0f);
  }
  float braking() const {
    return GetField<float>(VT_BRAKING, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_THROTTLE) &&
           VerifyField<float>(verifier, VT_STEERING) &&
           VerifyField<float>(verifier, VT_BRAKING) &&
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
           verifier.EndTable();
  }
};

struct ControlBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
<<<<<<< HEAD
=======
  void add_throttle(float throttle) {
    fbb_.AddElement<float>(Control::VT_THROTTLE, throttle, 0.0f);
  }
  void add_steering(float steering) {
    fbb_.AddElement<float>(Control::VT_STEERING, steering, 0.0f);
  }
  void add_braking(float braking) {
    fbb_.AddElement<float>(Control::VT_BRAKING, braking, 0.0f);
  }
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
  explicit ControlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControlBuilder &operator=(const ControlBuilder &);
  flatbuffers::Offset<Control> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Control>(end);
    return o;
  }
};

inline flatbuffers::Offset<Control> CreateControl(
<<<<<<< HEAD
    flatbuffers::FlatBufferBuilder &_fbb) {
  ControlBuilder builder_(_fbb);
=======
    flatbuffers::FlatBufferBuilder &_fbb,
    float throttle = 0.0f,
    float steering = 0.0f,
    float braking = 0.0f) {
  ControlBuilder builder_(_fbb);
  builder_.add_braking(braking);
  builder_.add_steering(steering);
  builder_.add_throttle(throttle);
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
  return builder_.Finish();
}

struct Time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  float t() const {
    return GetField<float>(VT_T, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_T) &&
           verifier.EndTable();
  }
};

struct TimeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_t(float t) {
    fbb_.AddElement<float>(Time::VT_T, t, 0.0f);
  }
  explicit TimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeBuilder &operator=(const TimeBuilder &);
  flatbuffers::Offset<Time> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Time>(end);
    return o;
  }
};

inline flatbuffers::Offset<Time> CreateTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    float t = 0.0f) {
  TimeBuilder builder_(_fbb);
  builder_.add_t(t);
  return builder_.Finish();
}

struct Exit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           verifier.EndTable();
  }
};

struct ExitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(Exit::VT_CODE, code, 0);
  }
  explicit ExitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExitBuilder &operator=(const ExitBuilder &);
  flatbuffers::Offset<Exit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exit> CreateExit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0) {
  ExitBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

<<<<<<< HEAD
struct Config FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSPORTS_TYPE = 4,
    VT_TRANSPORTS = 6,
    VT_FREQ = 8,
    VT_OFFSET = 10
  };
  const flatbuffers::Vector<uint8_t> *transports_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TRANSPORTS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *transports() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_TRANSPORTS);
  }
  int32_t freq() const {
    return GetField<int32_t>(VT_FREQ, 0);
  }
  const flatbuffers::Vector<float> *offset() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_OFFSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRANSPORTS_TYPE) &&
           verifier.VerifyVector(transports_type()) &&
           VerifyOffset(verifier, VT_TRANSPORTS) &&
           verifier.VerifyVector(transports()) &&
           VerifyTypeVector(verifier, transports(), transports_type()) &&
           VerifyField<int32_t>(verifier, VT_FREQ) &&
           VerifyOffset(verifier, VT_OFFSET) &&
           verifier.VerifyVector(offset()) &&
           verifier.EndTable();
  }
};

struct ConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transports_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> transports_type) {
    fbb_.AddOffset(Config::VT_TRANSPORTS_TYPE, transports_type);
  }
  void add_transports(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> transports) {
    fbb_.AddOffset(Config::VT_TRANSPORTS, transports);
  }
  void add_freq(int32_t freq) {
    fbb_.AddElement<int32_t>(Config::VT_FREQ, freq, 0);
  }
  void add_offset(flatbuffers::Offset<flatbuffers::Vector<float>> offset) {
    fbb_.AddOffset(Config::VT_OFFSET, offset);
  }
  explicit ConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConfigBuilder &operator=(const ConfigBuilder &);
  flatbuffers::Offset<Config> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Config>(end);
    return o;
  }
};

inline flatbuffers::Offset<Config> CreateConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> transports_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> transports = 0,
    int32_t freq = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> offset = 0) {
  ConfigBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_freq(freq);
  builder_.add_transports(transports);
  builder_.add_transports_type(transports_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Config> CreateConfigDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *transports_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *transports = nullptr,
    int32_t freq = 0,
    const std::vector<float> *offset = nullptr) {
  auto transports_type__ = transports_type ? _fbb.CreateVector<uint8_t>(*transports_type) : 0;
  auto transports__ = transports ? _fbb.CreateVector<flatbuffers::Offset<void>>(*transports) : 0;
  auto offset__ = offset ? _fbb.CreateVector<float>(*offset) : 0;
  return ChInterfaceMessage::CreateConfig(
      _fbb,
      transports_type__,
      transports__,
      freq,
      offset__);
}

struct Transport FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENSOR_TYPE = 4,
    VT_SENSOR = 6,
    VT_ID = 8,
    VT_FREQ = 10,
    VT_OFFSET = 12
  };
  Type sensor_type() const {
    return static_cast<Type>(GetField<uint8_t>(VT_SENSOR_TYPE, 0));
  }
  const void *sensor() const {
    return GetPointer<const void *>(VT_SENSOR);
  }
  template<typename T> const T *sensor_as() const;
  const Camera *sensor_as_Camera() const {
    return sensor_type() == Type_Camera ? static_cast<const Camera *>(sensor()) : nullptr;
  }
  const Lidar *sensor_as_Lidar() const {
    return sensor_type() == Type_Lidar ? static_cast<const Lidar *>(sensor()) : nullptr;
  }
  const GPS *sensor_as_GPS() const {
    return sensor_type() == Type_GPS ? static_cast<const GPS *>(sensor()) : nullptr;
  }
  const IMU *sensor_as_IMU() const {
    return sensor_type() == Type_IMU ? static_cast<const IMU *>(sensor()) : nullptr;
  }
  const Control *sensor_as_Control() const {
    return sensor_type() == Type_Control ? static_cast<const Control *>(sensor()) : nullptr;
  }
  const Time *sensor_as_Time() const {
    return sensor_type() == Type_Time ? static_cast<const Time *>(sensor()) : nullptr;
  }
  const Exit *sensor_as_Exit() const {
    return sensor_type() == Type_Exit ? static_cast<const Exit *>(sensor()) : nullptr;
  }
  const Config *sensor_as_Config() const {
    return sensor_type() == Type_Config ? static_cast<const Config *>(sensor()) : nullptr;
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int32_t freq() const {
    return GetField<int32_t>(VT_FREQ, 0);
  }
  const flatbuffers::Vector<float> *offset() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_OFFSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SENSOR_TYPE) &&
           VerifyOffset(verifier, VT_SENSOR) &&
           VerifyType(verifier, sensor(), sensor_type()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int32_t>(verifier, VT_FREQ) &&
           VerifyOffset(verifier, VT_OFFSET) &&
           verifier.VerifyVector(offset()) &&
           verifier.EndTable();
  }
};

template<> inline const Camera *Transport::sensor_as<Camera>() const {
  return sensor_as_Camera();
}

template<> inline const Lidar *Transport::sensor_as<Lidar>() const {
  return sensor_as_Lidar();
}

template<> inline const GPS *Transport::sensor_as<GPS>() const {
  return sensor_as_GPS();
}

template<> inline const IMU *Transport::sensor_as<IMU>() const {
  return sensor_as_IMU();
}

template<> inline const Control *Transport::sensor_as<Control>() const {
  return sensor_as_Control();
}

template<> inline const Time *Transport::sensor_as<Time>() const {
  return sensor_as_Time();
}

template<> inline const Exit *Transport::sensor_as<Exit>() const {
  return sensor_as_Exit();
}

template<> inline const Config *Transport::sensor_as<Config>() const {
  return sensor_as_Config();
}

struct TransportBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sensor_type(Type sensor_type) {
    fbb_.AddElement<uint8_t>(Transport::VT_SENSOR_TYPE, static_cast<uint8_t>(sensor_type), 0);
  }
  void add_sensor(flatbuffers::Offset<void> sensor) {
    fbb_.AddOffset(Transport::VT_SENSOR, sensor);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Transport::VT_ID, id);
  }
  void add_freq(int32_t freq) {
    fbb_.AddElement<int32_t>(Transport::VT_FREQ, freq, 0);
  }
  void add_offset(flatbuffers::Offset<flatbuffers::Vector<float>> offset) {
    fbb_.AddOffset(Transport::VT_OFFSET, offset);
  }
  explicit TransportBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransportBuilder &operator=(const TransportBuilder &);
  flatbuffers::Offset<Transport> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transport>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transport> CreateTransport(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type sensor_type = Type_NONE,
    flatbuffers::Offset<void> sensor = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int32_t freq = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> offset = 0) {
  TransportBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_freq(freq);
  builder_.add_id(id);
  builder_.add_sensor(sensor);
  builder_.add_sensor_type(sensor_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transport> CreateTransportDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type sensor_type = Type_NONE,
    flatbuffers::Offset<void> sensor = 0,
    const char *id = nullptr,
    int32_t freq = 0,
    const std::vector<float> *offset = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto offset__ = offset ? _fbb.CreateVector<float>(*offset) : 0;
  return ChInterfaceMessage::CreateTransport(
      _fbb,
      sensor_type,
      sensor,
      id__,
      freq,
      offset__);
}

=======
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Camera: {
<<<<<<< HEAD
      auto ptr = reinterpret_cast<const Camera *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Lidar: {
      auto ptr = reinterpret_cast<const Lidar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GPS: {
      auto ptr = reinterpret_cast<const GPS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_IMU: {
      auto ptr = reinterpret_cast<const IMU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Control: {
      auto ptr = reinterpret_cast<const Control *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Time: {
      auto ptr = reinterpret_cast<const Time *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Exit: {
      auto ptr = reinterpret_cast<const Exit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Config: {
      auto ptr = reinterpret_cast<const Config *>(obj);
=======
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Camera *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Lidar: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Lidar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GPS: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::GPS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_IMU: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::IMU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Control: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Control *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Time: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Time *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Exit: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Exit *>(obj);
>>>>>>> d84456083cd1453b3a85c92286e5fa9be41093f3
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const ChInterfaceMessage::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<ChInterfaceMessage::Message>(buf);
}

inline const ChInterfaceMessage::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ChInterfaceMessage::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ChInterfaceMessage::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ChInterfaceMessage::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ChInterfaceMessage::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ChInterfaceMessage::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ChInterfaceMessage

#endif  // FLATBUFFERS_GENERATED_CHINTERFACEMESSAGES_CHINTERFACEMESSAGE_H_
