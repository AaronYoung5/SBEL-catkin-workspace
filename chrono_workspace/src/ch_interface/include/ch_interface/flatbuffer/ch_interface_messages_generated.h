// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHINTERFACEMESSAGES_CHINTERFACEMESSAGE_H_
#define FLATBUFFERS_GENERATED_CHINTERFACEMESSAGES_CHINTERFACEMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

namespace ChInterfaceMessage {

struct Message;

struct Camera;

struct Lidar;

struct GPS;

struct IMU;

struct Control;

struct Time;

struct Exit;

struct Config;

enum Type {
  Type_NONE = 0,
  Type_Camera = 1,
  Type_Lidar = 2,
  Type_GPS = 3,
  Type_IMU = 4,
  Type_Control = 5,
  Type_Time = 6,
  Type_Exit = 7,
  Type_Config = 8,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Config
};

inline const Type (&EnumValuesType())[9] {
  static const Type values[] = {
    Type_NONE,
    Type_Camera,
    Type_Lidar,
    Type_GPS,
    Type_IMU,
    Type_Control,
    Type_Time,
    Type_Exit,
    Type_Config
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[10] = {
    "NONE",
    "Camera",
    "Lidar",
    "GPS",
    "IMU",
    "Control",
    "Time",
    "Exit",
    "Config",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_Config) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<ChInterfaceMessage::Camera> {
  static const Type enum_value = Type_Camera;
};

template<> struct TypeTraits<ChInterfaceMessage::Lidar> {
  static const Type enum_value = Type_Lidar;
};

template<> struct TypeTraits<ChInterfaceMessage::GPS> {
  static const Type enum_value = Type_GPS;
};

template<> struct TypeTraits<ChInterfaceMessage::IMU> {
  static const Type enum_value = Type_IMU;
};

template<> struct TypeTraits<ChInterfaceMessage::Control> {
  static const Type enum_value = Type_Control;
};

template<> struct TypeTraits<ChInterfaceMessage::Time> {
  static const Type enum_value = Type_Time;
};

template<> struct TypeTraits<ChInterfaceMessage::Exit> {
  static const Type enum_value = Type_Exit;
};

template<> struct TypeTraits<ChInterfaceMessage::Config> {
  static const Type enum_value = Type_Config;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
    VT_ID = 8
  };
  ChInterfaceMessage::Type message_type() const {
    return static_cast<ChInterfaceMessage::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const ChInterfaceMessage::Camera *message_as_Camera() const {
    return message_type() == ChInterfaceMessage::Type_Camera ? static_cast<const ChInterfaceMessage::Camera *>(message()) : nullptr;
  }
  const ChInterfaceMessage::Lidar *message_as_Lidar() const {
    return message_type() == ChInterfaceMessage::Type_Lidar ? static_cast<const ChInterfaceMessage::Lidar *>(message()) : nullptr;
  }
  const ChInterfaceMessage::GPS *message_as_GPS() const {
    return message_type() == ChInterfaceMessage::Type_GPS ? static_cast<const ChInterfaceMessage::GPS *>(message()) : nullptr;
  }
  const ChInterfaceMessage::IMU *message_as_IMU() const {
    return message_type() == ChInterfaceMessage::Type_IMU ? static_cast<const ChInterfaceMessage::IMU *>(message()) : nullptr;
  }
  const ChInterfaceMessage::Control *message_as_Control() const {
    return message_type() == ChInterfaceMessage::Type_Control ? static_cast<const ChInterfaceMessage::Control *>(message()) : nullptr;
  }
  const ChInterfaceMessage::Time *message_as_Time() const {
    return message_type() == ChInterfaceMessage::Type_Time ? static_cast<const ChInterfaceMessage::Time *>(message()) : nullptr;
  }
  const ChInterfaceMessage::Exit *message_as_Exit() const {
    return message_type() == ChInterfaceMessage::Type_Exit ? static_cast<const ChInterfaceMessage::Exit *>(message()) : nullptr;
  }
  const ChInterfaceMessage::Config *message_as_Config() const {
    return message_type() == ChInterfaceMessage::Type_Config ? static_cast<const ChInterfaceMessage::Config *>(message()) : nullptr;
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

template<> inline const ChInterfaceMessage::Camera *Message::message_as<ChInterfaceMessage::Camera>() const {
  return message_as_Camera();
}

template<> inline const ChInterfaceMessage::Lidar *Message::message_as<ChInterfaceMessage::Lidar>() const {
  return message_as_Lidar();
}

template<> inline const ChInterfaceMessage::GPS *Message::message_as<ChInterfaceMessage::GPS>() const {
  return message_as_GPS();
}

template<> inline const ChInterfaceMessage::IMU *Message::message_as<ChInterfaceMessage::IMU>() const {
  return message_as_IMU();
}

template<> inline const ChInterfaceMessage::Control *Message::message_as<ChInterfaceMessage::Control>() const {
  return message_as_Control();
}

template<> inline const ChInterfaceMessage::Time *Message::message_as<ChInterfaceMessage::Time>() const {
  return message_as_Time();
}

template<> inline const ChInterfaceMessage::Exit *Message::message_as<ChInterfaceMessage::Exit>() const {
  return message_as_Exit();
}

template<> inline const ChInterfaceMessage::Config *Message::message_as<ChInterfaceMessage::Config>() const {
  return message_as_Config();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(ChInterfaceMessage::Type message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Message::VT_ID, id);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    ChInterfaceMessage::Type message_type = ChInterfaceMessage::Type_NONE,
    flatbuffers::Offset<void> message = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ChInterfaceMessage::Type message_type = ChInterfaceMessage::Type_NONE,
    flatbuffers::Offset<void> message = 0,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return ChInterfaceMessage::CreateMessage(
      _fbb,
      message_type,
      message,
      id__);
}

struct Camera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_WIDTH = 6,
    VT_BYTES_PER_PIXEL = 8,
    VT_DATA = 10
  };
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t bytes_per_pixel() const {
    return GetField<int32_t>(VT_BYTES_PER_PIXEL, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_BYTES_PER_PIXEL) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct CameraBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(Camera::VT_HEIGHT, height, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Camera::VT_WIDTH, width, 0);
  }
  void add_bytes_per_pixel(int32_t bytes_per_pixel) {
    fbb_.AddElement<int32_t>(Camera::VT_BYTES_PER_PIXEL, bytes_per_pixel, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Camera::VT_DATA, data);
  }
  explicit CameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CameraBuilder &operator=(const CameraBuilder &);
  flatbuffers::Offset<Camera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Camera>(end);
    return o;
  }
};

inline flatbuffers::Offset<Camera> CreateCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    int32_t bytes_per_pixel = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  CameraBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_bytes_per_pixel(bytes_per_pixel);
  builder_.add_width(width);
  builder_.add_height(height);
  return builder_.Finish();
}

inline flatbuffers::Offset<Camera> CreateCameraDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    int32_t bytes_per_pixel = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return ChInterfaceMessage::CreateCamera(
      _fbb,
      height,
      width,
      bytes_per_pixel,
      data__);
}

struct Lidar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LidarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LidarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LidarBuilder &operator=(const LidarBuilder &);
  flatbuffers::Offset<Lidar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lidar>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lidar> CreateLidar(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LidarBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GPS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GPSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GPSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GPSBuilder &operator=(const GPSBuilder &);
  flatbuffers::Offset<GPS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GPS>(end);
    return o;
  }
};

inline flatbuffers::Offset<GPS> CreateGPS(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GPSBuilder builder_(_fbb);
  return builder_.Finish();
}

struct IMU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct IMUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IMUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IMUBuilder &operator=(const IMUBuilder &);
  flatbuffers::Offset<IMU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IMU>(end);
    return o;
  }
};

inline flatbuffers::Offset<IMU> CreateIMU(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IMUBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Control FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ControlBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ControlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControlBuilder &operator=(const ControlBuilder &);
  flatbuffers::Offset<Control> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Control>(end);
    return o;
  }
};

inline flatbuffers::Offset<Control> CreateControl(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ControlBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  float t() const {
    return GetField<float>(VT_T, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_T) &&
           verifier.EndTable();
  }
};

struct TimeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_t(float t) {
    fbb_.AddElement<float>(Time::VT_T, t, 0.0f);
  }
  explicit TimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeBuilder &operator=(const TimeBuilder &);
  flatbuffers::Offset<Time> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Time>(end);
    return o;
  }
};

inline flatbuffers::Offset<Time> CreateTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    float t = 0.0f) {
  TimeBuilder builder_(_fbb);
  builder_.add_t(t);
  return builder_.Finish();
}

struct Exit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           verifier.EndTable();
  }
};

struct ExitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(Exit::VT_CODE, code, 0);
  }
  explicit ExitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExitBuilder &operator=(const ExitBuilder &);
  flatbuffers::Offset<Exit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exit> CreateExit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0) {
  ExitBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

struct Config FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConfigBuilder &operator=(const ConfigBuilder &);
  flatbuffers::Offset<Config> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Config>(end);
    return o;
  }
};

inline flatbuffers::Offset<Config> CreateConfig(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ConfigBuilder builder_(_fbb);
  return builder_.Finish();
}

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Camera: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Camera *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Lidar: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Lidar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GPS: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::GPS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_IMU: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::IMU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Control: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Control *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Time: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Time *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Exit: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Exit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Config: {
      auto ptr = reinterpret_cast<const ChInterfaceMessage::Config *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const ChInterfaceMessage::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<ChInterfaceMessage::Message>(buf);
}

inline const ChInterfaceMessage::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ChInterfaceMessage::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ChInterfaceMessage::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ChInterfaceMessage::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ChInterfaceMessage::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ChInterfaceMessage::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ChInterfaceMessage

#endif  // FLATBUFFERS_GENERATED_CHINTERFACEMESSAGES_CHINTERFACEMESSAGE_H_
