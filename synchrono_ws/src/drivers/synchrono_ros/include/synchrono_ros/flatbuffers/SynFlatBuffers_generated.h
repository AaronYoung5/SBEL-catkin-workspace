// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace SynFlatBuffers {
namespace SPAT {

struct State;

struct Lane;

}  // namespace SPAT

namespace MAP {

struct State;

struct Lane;

struct Vector;

struct Pose;

struct Quaternion;

}  // namespace MAP

namespace Agent {
namespace TrafficLight {

struct State;

}  // namespace TrafficLight

namespace Sedan {

struct State;

}  // namespace Sedan

struct State;

struct Pose;

struct Vector;

struct Quaternion;

}  // namespace Agent

namespace Interface {

struct State;

struct Camera;

struct Lidar;

struct GPS;

struct IMU;

struct Control;

struct Time;

struct Exit;

}  // namespace Interface

struct Buffer;

struct Message;

struct Pointer;

namespace SPAT {

enum Color {
  Color_Green = 0,
  Color_Yellow = 1,
  Color_Red = 2,
  Color_MIN = Color_Green,
  Color_MAX = Color_Red
};

inline const Color (&EnumValuesColor())[3] {
  static const Color values[] = {
    Color_Green,
    Color_Yellow,
    Color_Red
  };
  return values;
}

inline const char * const *EnumNamesColor() {
  static const char * const names[4] = {
    "Green",
    "Yellow",
    "Red",
    nullptr
  };
  return names;
}

inline const char *EnumNameColor(Color e) {
  if (e < Color_Green || e > Color_Red) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColor()[index];
}

}  // namespace SPAT

namespace Agent {

enum Type {
  Type_NONE = 0,
  Type_Sedan_State = 1,
  Type_TrafficLight_State = 2,
  Type_MIN = Type_NONE,
  Type_MAX = Type_TrafficLight_State
};

inline const Type (&EnumValuesType())[3] {
  static const Type values[] = {
    Type_NONE,
    Type_Sedan_State,
    Type_TrafficLight_State
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[4] = {
    "NONE",
    "Sedan_State",
    "TrafficLight_State",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_TrafficLight_State) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::Sedan::State> {
  static const Type enum_value = Type_Sedan_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::TrafficLight::State> {
  static const Type enum_value = Type_TrafficLight_State;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Agent

namespace Interface {

enum Type {
  Type_NONE = 0,
  Type_Camera = 1,
  Type_Lidar = 2,
  Type_GPS = 3,
  Type_IMU = 4,
  Type_Control = 5,
  Type_Time = 6,
  Type_Exit = 7,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Exit
};

inline const Type (&EnumValuesType())[8] {
  static const Type values[] = {
    Type_NONE,
    Type_Camera,
    Type_Lidar,
    Type_GPS,
    Type_IMU,
    Type_Control,
    Type_Time,
    Type_Exit
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[9] = {
    "NONE",
    "Camera",
    "Lidar",
    "GPS",
    "IMU",
    "Control",
    "Time",
    "Exit",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_Exit) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::Camera> {
  static const Type enum_value = Type_Camera;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::Lidar> {
  static const Type enum_value = Type_Lidar;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::GPS> {
  static const Type enum_value = Type_GPS;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::IMU> {
  static const Type enum_value = Type_IMU;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::Control> {
  static const Type enum_value = Type_Control;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::Time> {
  static const Type enum_value = Type_Time;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::Exit> {
  static const Type enum_value = Type_Exit;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Interface

enum Type {
  Type_NONE = 0,
  Type_Pointer = 1,
  Type_Agent_State = 2,
  Type_Interface_State = 3,
  Type_SPAT_State = 4,
  Type_MAP_State = 5,
  Type_MIN = Type_NONE,
  Type_MAX = Type_MAP_State
};

inline const Type (&EnumValuesType())[6] {
  static const Type values[] = {
    Type_NONE,
    Type_Pointer,
    Type_Agent_State,
    Type_Interface_State,
    Type_SPAT_State,
    Type_MAP_State
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[7] = {
    "NONE",
    "Pointer",
    "Agent_State",
    "Interface_State",
    "SPAT_State",
    "MAP_State",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_MAP_State) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Pointer> {
  static const Type enum_value = Type_Pointer;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::State> {
  static const Type enum_value = Type_Agent_State;
};

template<> struct TypeTraits<SynFlatBuffers::Interface::State> {
  static const Type enum_value = Type_Interface_State;
};

template<> struct TypeTraits<SynFlatBuffers::SPAT::State> {
  static const Type enum_value = Type_SPAT_State;
};

template<> struct TypeTraits<SynFlatBuffers::MAP::State> {
  static const Type enum_value = Type_MAP_State;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

namespace SPAT {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_SENDER = 6,
    VT_INTERSECTION = 8,
    VT_LANES = 10
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  double sender() const {
    return GetField<double>(VT_SENDER, 0.0);
  }
  double intersection() const {
    return GetField<double>(VT_INTERSECTION, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *lanes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *>(VT_LANES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyField<double>(verifier, VT_SENDER) &&
           VerifyField<double>(verifier, VT_INTERSECTION) &&
           VerifyOffset(verifier, VT_LANES) &&
           verifier.VerifyVector(lanes()) &&
           verifier.VerifyVectorOfTables(lanes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_sender(double sender) {
    fbb_.AddElement<double>(State::VT_SENDER, sender, 0.0);
  }
  void add_intersection(double intersection) {
    fbb_.AddElement<double>(State::VT_INTERSECTION, intersection, 0.0);
  }
  void add_lanes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>> lanes) {
    fbb_.AddOffset(State::VT_LANES, lanes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    double sender = 0.0,
    double intersection = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>> lanes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_intersection(intersection);
  builder_.add_sender(sender);
  builder_.add_time(time);
  builder_.add_lanes(lanes);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    double sender = 0.0,
    double intersection = 0.0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *lanes = nullptr) {
  auto lanes__ = lanes ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>(*lanes) : 0;
  return SynFlatBuffers::SPAT::CreateState(
      _fbb,
      time,
      sender,
      intersection,
      lanes__);
}

struct Lane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4
  };
  SynFlatBuffers::SPAT::Color color() const {
    return static_cast<SynFlatBuffers::SPAT::Color>(GetField<int8_t>(VT_COLOR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
};

struct LaneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color(SynFlatBuffers::SPAT::Color color) {
    fbb_.AddElement<int8_t>(Lane::VT_COLOR, static_cast<int8_t>(color), 0);
  }
  explicit LaneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaneBuilder &operator=(const LaneBuilder &);
  flatbuffers::Offset<Lane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lane>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lane> CreateLane(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::SPAT::Color color = SynFlatBuffers::SPAT::Color_Green) {
  LaneBuilder builder_(_fbb);
  builder_.add_color(color);
  return builder_.Finish();
}

}  // namespace SPAT

namespace MAP {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_SENDER = 6,
    VT_INTERSECTION = 8,
    VT_LANES = 10
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  double sender() const {
    return GetField<double>(VT_SENDER, 0.0);
  }
  double intersection() const {
    return GetField<double>(VT_INTERSECTION, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>> *lanes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>> *>(VT_LANES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyField<double>(verifier, VT_SENDER) &&
           VerifyField<double>(verifier, VT_INTERSECTION) &&
           VerifyOffset(verifier, VT_LANES) &&
           verifier.VerifyVector(lanes()) &&
           verifier.VerifyVectorOfTables(lanes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_sender(double sender) {
    fbb_.AddElement<double>(State::VT_SENDER, sender, 0.0);
  }
  void add_intersection(double intersection) {
    fbb_.AddElement<double>(State::VT_INTERSECTION, intersection, 0.0);
  }
  void add_lanes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>>> lanes) {
    fbb_.AddOffset(State::VT_LANES, lanes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    double sender = 0.0,
    double intersection = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>>> lanes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_intersection(intersection);
  builder_.add_sender(sender);
  builder_.add_time(time);
  builder_.add_lanes(lanes);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    double sender = 0.0,
    double intersection = 0.0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>> *lanes = nullptr) {
  auto lanes__ = lanes ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::MAP::Lane>>(*lanes) : 0;
  return SynFlatBuffers::MAP::CreateState(
      _fbb,
      time,
      sender,
      intersection,
      lanes__);
}

struct Lane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_STOPPOS = 6,
    VT_OFFSETPOS = 8
  };
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  const SynFlatBuffers::MAP::Vector *stopPos() const {
    return GetPointer<const SynFlatBuffers::MAP::Vector *>(VT_STOPPOS);
  }
  const SynFlatBuffers::MAP::Vector *offsetPos() const {
    return GetPointer<const SynFlatBuffers::MAP::Vector *>(VT_OFFSETPOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_WIDTH) &&
           VerifyOffset(verifier, VT_STOPPOS) &&
           verifier.VerifyTable(stopPos()) &&
           VerifyOffset(verifier, VT_OFFSETPOS) &&
           verifier.VerifyTable(offsetPos()) &&
           verifier.EndTable();
  }
};

struct LaneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_width(double width) {
    fbb_.AddElement<double>(Lane::VT_WIDTH, width, 0.0);
  }
  void add_stopPos(flatbuffers::Offset<SynFlatBuffers::MAP::Vector> stopPos) {
    fbb_.AddOffset(Lane::VT_STOPPOS, stopPos);
  }
  void add_offsetPos(flatbuffers::Offset<SynFlatBuffers::MAP::Vector> offsetPos) {
    fbb_.AddOffset(Lane::VT_OFFSETPOS, offsetPos);
  }
  explicit LaneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaneBuilder &operator=(const LaneBuilder &);
  flatbuffers::Offset<Lane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lane>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lane> CreateLane(
    flatbuffers::FlatBufferBuilder &_fbb,
    double width = 0.0,
    flatbuffers::Offset<SynFlatBuffers::MAP::Vector> stopPos = 0,
    flatbuffers::Offset<SynFlatBuffers::MAP::Vector> offsetPos = 0) {
  LaneBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_offsetPos(offsetPos);
  builder_.add_stopPos(stopPos);
  return builder_.Finish();
}

struct Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Vector::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector::VT_Z, z, 0.0);
  }
  explicit VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorBuilder &operator=(const VectorBuilder &);
  flatbuffers::Offset<Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector> CreateVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  VectorBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Pose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_ROT = 6
  };
  const SynFlatBuffers::MAP::Vector *pos() const {
    return GetPointer<const SynFlatBuffers::MAP::Vector *>(VT_POS);
  }
  const SynFlatBuffers::MAP::Quaternion *rot() const {
    return GetPointer<const SynFlatBuffers::MAP::Quaternion *>(VT_ROT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyOffset(verifier, VT_ROT) &&
           verifier.VerifyTable(rot()) &&
           verifier.EndTable();
  }
};

struct PoseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(flatbuffers::Offset<SynFlatBuffers::MAP::Vector> pos) {
    fbb_.AddOffset(Pose::VT_POS, pos);
  }
  void add_rot(flatbuffers::Offset<SynFlatBuffers::MAP::Quaternion> rot) {
    fbb_.AddOffset(Pose::VT_ROT, rot);
  }
  explicit PoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoseBuilder &operator=(const PoseBuilder &);
  flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pose> CreatePose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SynFlatBuffers::MAP::Vector> pos = 0,
    flatbuffers::Offset<SynFlatBuffers::MAP::Quaternion> rot = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_rot(rot);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_E0 = 4,
    VT_E1 = 6,
    VT_E2 = 8,
    VT_E3 = 10
  };
  double e0() const {
    return GetField<double>(VT_E0, 0.0);
  }
  double e1() const {
    return GetField<double>(VT_E1, 0.0);
  }
  double e2() const {
    return GetField<double>(VT_E2, 0.0);
  }
  double e3() const {
    return GetField<double>(VT_E3, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_E0) &&
           VerifyField<double>(verifier, VT_E1) &&
           VerifyField<double>(verifier, VT_E2) &&
           VerifyField<double>(verifier, VT_E3) &&
           verifier.EndTable();
  }
};

struct QuaternionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_e0(double e0) {
    fbb_.AddElement<double>(Quaternion::VT_E0, e0, 0.0);
  }
  void add_e1(double e1) {
    fbb_.AddElement<double>(Quaternion::VT_E1, e1, 0.0);
  }
  void add_e2(double e2) {
    fbb_.AddElement<double>(Quaternion::VT_E2, e2, 0.0);
  }
  void add_e3(double e3) {
    fbb_.AddElement<double>(Quaternion::VT_E3, e3, 0.0);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuaternionBuilder &operator=(const QuaternionBuilder &);
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    double e0 = 0.0,
    double e1 = 0.0,
    double e2 = 0.0,
    double e3 = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_e3(e3);
  builder_.add_e2(e2);
  builder_.add_e1(e1);
  builder_.add_e0(e0);
  return builder_.Finish();
}

}  // namespace MAP

namespace Agent {
namespace TrafficLight {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_MAP = 6,
    VT_SPAT = 8
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const SynFlatBuffers::MAP::State *map() const {
    return GetPointer<const SynFlatBuffers::MAP::State *>(VT_MAP);
  }
  const SynFlatBuffers::SPAT::State *spat() const {
    return GetPointer<const SynFlatBuffers::SPAT::State *>(VT_SPAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           VerifyOffset(verifier, VT_SPAT) &&
           verifier.VerifyTable(spat()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_map(flatbuffers::Offset<SynFlatBuffers::MAP::State> map) {
    fbb_.AddOffset(State::VT_MAP, map);
  }
  void add_spat(flatbuffers::Offset<SynFlatBuffers::SPAT::State> spat) {
    fbb_.AddOffset(State::VT_SPAT, spat);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::MAP::State> map = 0,
    flatbuffers::Offset<SynFlatBuffers::SPAT::State> spat = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_spat(spat);
  builder_.add_map(map);
  return builder_.Finish();
}

}  // namespace TrafficLight

namespace Sedan {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CHASSIS = 6,
    VT_WHEEL0 = 8,
    VT_WHEEL1 = 10,
    VT_WHEEL2 = 12,
    VT_WHEEL3 = 14
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const SynFlatBuffers::Agent::Pose *chassis() const {
    return GetPointer<const SynFlatBuffers::Agent::Pose *>(VT_CHASSIS);
  }
  const SynFlatBuffers::Agent::Pose *wheel0() const {
    return GetPointer<const SynFlatBuffers::Agent::Pose *>(VT_WHEEL0);
  }
  const SynFlatBuffers::Agent::Pose *wheel1() const {
    return GetPointer<const SynFlatBuffers::Agent::Pose *>(VT_WHEEL1);
  }
  const SynFlatBuffers::Agent::Pose *wheel2() const {
    return GetPointer<const SynFlatBuffers::Agent::Pose *>(VT_WHEEL2);
  }
  const SynFlatBuffers::Agent::Pose *wheel3() const {
    return GetPointer<const SynFlatBuffers::Agent::Pose *>(VT_WHEEL3);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_CHASSIS) &&
           verifier.VerifyTable(chassis()) &&
           VerifyOffset(verifier, VT_WHEEL0) &&
           verifier.VerifyTable(wheel0()) &&
           VerifyOffset(verifier, VT_WHEEL1) &&
           verifier.VerifyTable(wheel1()) &&
           VerifyOffset(verifier, VT_WHEEL2) &&
           verifier.VerifyTable(wheel2()) &&
           VerifyOffset(verifier, VT_WHEEL3) &&
           verifier.VerifyTable(wheel3()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_chassis(flatbuffers::Offset<SynFlatBuffers::Agent::Pose> chassis) {
    fbb_.AddOffset(State::VT_CHASSIS, chassis);
  }
  void add_wheel0(flatbuffers::Offset<SynFlatBuffers::Agent::Pose> wheel0) {
    fbb_.AddOffset(State::VT_WHEEL0, wheel0);
  }
  void add_wheel1(flatbuffers::Offset<SynFlatBuffers::Agent::Pose> wheel1) {
    fbb_.AddOffset(State::VT_WHEEL1, wheel1);
  }
  void add_wheel2(flatbuffers::Offset<SynFlatBuffers::Agent::Pose> wheel2) {
    fbb_.AddOffset(State::VT_WHEEL2, wheel2);
  }
  void add_wheel3(flatbuffers::Offset<SynFlatBuffers::Agent::Pose> wheel3) {
    fbb_.AddOffset(State::VT_WHEEL3, wheel3);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Agent::Pose> chassis = 0,
    flatbuffers::Offset<SynFlatBuffers::Agent::Pose> wheel0 = 0,
    flatbuffers::Offset<SynFlatBuffers::Agent::Pose> wheel1 = 0,
    flatbuffers::Offset<SynFlatBuffers::Agent::Pose> wheel2 = 0,
    flatbuffers::Offset<SynFlatBuffers::Agent::Pose> wheel3 = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_wheel3(wheel3);
  builder_.add_wheel2(wheel2);
  builder_.add_wheel1(wheel1);
  builder_.add_wheel0(wheel0);
  builder_.add_chassis(chassis);
  return builder_.Finish();
}

}  // namespace Sedan

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  SynFlatBuffers::Agent::Type message_type() const {
    return static_cast<SynFlatBuffers::Agent::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const SynFlatBuffers::Agent::Sedan::State *message_as_Sedan_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_Sedan_State ? static_cast<const SynFlatBuffers::Agent::Sedan::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::TrafficLight::State *message_as_TrafficLight_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_TrafficLight_State ? static_cast<const SynFlatBuffers::Agent::TrafficLight::State *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Agent::Sedan::State *State::message_as<SynFlatBuffers::Agent::Sedan::State>() const {
  return message_as_Sedan_State();
}

template<> inline const SynFlatBuffers::Agent::TrafficLight::State *State::message_as<SynFlatBuffers::Agent::TrafficLight::State>() const {
  return message_as_TrafficLight_State();
}

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(SynFlatBuffers::Agent::Type message_type) {
    fbb_.AddElement<uint8_t>(State::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(State::VT_MESSAGE, message);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Agent::Type message_type = SynFlatBuffers::Agent::Type_NONE,
    flatbuffers::Offset<void> message = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct Pose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_ROT = 6
  };
  const SynFlatBuffers::Agent::Vector *pos() const {
    return GetPointer<const SynFlatBuffers::Agent::Vector *>(VT_POS);
  }
  const SynFlatBuffers::Agent::Quaternion *rot() const {
    return GetPointer<const SynFlatBuffers::Agent::Quaternion *>(VT_ROT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyOffset(verifier, VT_ROT) &&
           verifier.VerifyTable(rot()) &&
           verifier.EndTable();
  }
};

struct PoseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(flatbuffers::Offset<SynFlatBuffers::Agent::Vector> pos) {
    fbb_.AddOffset(Pose::VT_POS, pos);
  }
  void add_rot(flatbuffers::Offset<SynFlatBuffers::Agent::Quaternion> rot) {
    fbb_.AddOffset(Pose::VT_ROT, rot);
  }
  explicit PoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoseBuilder &operator=(const PoseBuilder &);
  flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pose> CreatePose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SynFlatBuffers::Agent::Vector> pos = 0,
    flatbuffers::Offset<SynFlatBuffers::Agent::Quaternion> rot = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_rot(rot);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Vector::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector::VT_Z, z, 0.0);
  }
  explicit VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorBuilder &operator=(const VectorBuilder &);
  flatbuffers::Offset<Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector> CreateVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  VectorBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_E0 = 4,
    VT_E1 = 6,
    VT_E2 = 8,
    VT_E3 = 10
  };
  double e0() const {
    return GetField<double>(VT_E0, 0.0);
  }
  double e1() const {
    return GetField<double>(VT_E1, 0.0);
  }
  double e2() const {
    return GetField<double>(VT_E2, 0.0);
  }
  double e3() const {
    return GetField<double>(VT_E3, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_E0) &&
           VerifyField<double>(verifier, VT_E1) &&
           VerifyField<double>(verifier, VT_E2) &&
           VerifyField<double>(verifier, VT_E3) &&
           verifier.EndTable();
  }
};

struct QuaternionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_e0(double e0) {
    fbb_.AddElement<double>(Quaternion::VT_E0, e0, 0.0);
  }
  void add_e1(double e1) {
    fbb_.AddElement<double>(Quaternion::VT_E1, e1, 0.0);
  }
  void add_e2(double e2) {
    fbb_.AddElement<double>(Quaternion::VT_E2, e2, 0.0);
  }
  void add_e3(double e3) {
    fbb_.AddElement<double>(Quaternion::VT_E3, e3, 0.0);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuaternionBuilder &operator=(const QuaternionBuilder &);
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    double e0 = 0.0,
    double e1 = 0.0,
    double e2 = 0.0,
    double e3 = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_e3(e3);
  builder_.add_e2(e2);
  builder_.add_e1(e1);
  builder_.add_e0(e0);
  return builder_.Finish();
}

}  // namespace Agent

namespace Interface {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE_TYPE = 4,
    VT_STATE = 6,
    VT_TIME = 8
  };
  SynFlatBuffers::Interface::Type state_type() const {
    return static_cast<SynFlatBuffers::Interface::Type>(GetField<uint8_t>(VT_STATE_TYPE, 0));
  }
  const void *state() const {
    return GetPointer<const void *>(VT_STATE);
  }
  template<typename T> const T *state_as() const;
  const SynFlatBuffers::Interface::Camera *state_as_Camera() const {
    return state_type() == SynFlatBuffers::Interface::Type_Camera ? static_cast<const SynFlatBuffers::Interface::Camera *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::Lidar *state_as_Lidar() const {
    return state_type() == SynFlatBuffers::Interface::Type_Lidar ? static_cast<const SynFlatBuffers::Interface::Lidar *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::GPS *state_as_GPS() const {
    return state_type() == SynFlatBuffers::Interface::Type_GPS ? static_cast<const SynFlatBuffers::Interface::GPS *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::IMU *state_as_IMU() const {
    return state_type() == SynFlatBuffers::Interface::Type_IMU ? static_cast<const SynFlatBuffers::Interface::IMU *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::Control *state_as_Control() const {
    return state_type() == SynFlatBuffers::Interface::Type_Control ? static_cast<const SynFlatBuffers::Interface::Control *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::Time *state_as_Time() const {
    return state_type() == SynFlatBuffers::Interface::Type_Time ? static_cast<const SynFlatBuffers::Interface::Time *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::Exit *state_as_Exit() const {
    return state_type() == SynFlatBuffers::Interface::Type_Exit ? static_cast<const SynFlatBuffers::Interface::Exit *>(state()) : nullptr;
  }
  const SynFlatBuffers::Interface::Time *time() const {
    return GetPointer<const SynFlatBuffers::Interface::Time *>(VT_TIME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATE_TYPE) &&
           VerifyOffset(verifier, VT_STATE) &&
           VerifyType(verifier, state(), state_type()) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.VerifyTable(time()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Interface::Camera *State::state_as<SynFlatBuffers::Interface::Camera>() const {
  return state_as_Camera();
}

template<> inline const SynFlatBuffers::Interface::Lidar *State::state_as<SynFlatBuffers::Interface::Lidar>() const {
  return state_as_Lidar();
}

template<> inline const SynFlatBuffers::Interface::GPS *State::state_as<SynFlatBuffers::Interface::GPS>() const {
  return state_as_GPS();
}

template<> inline const SynFlatBuffers::Interface::IMU *State::state_as<SynFlatBuffers::Interface::IMU>() const {
  return state_as_IMU();
}

template<> inline const SynFlatBuffers::Interface::Control *State::state_as<SynFlatBuffers::Interface::Control>() const {
  return state_as_Control();
}

template<> inline const SynFlatBuffers::Interface::Time *State::state_as<SynFlatBuffers::Interface::Time>() const {
  return state_as_Time();
}

template<> inline const SynFlatBuffers::Interface::Exit *State::state_as<SynFlatBuffers::Interface::Exit>() const {
  return state_as_Exit();
}

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state_type(SynFlatBuffers::Interface::Type state_type) {
    fbb_.AddElement<uint8_t>(State::VT_STATE_TYPE, static_cast<uint8_t>(state_type), 0);
  }
  void add_state(flatbuffers::Offset<void> state) {
    fbb_.AddOffset(State::VT_STATE, state);
  }
  void add_time(flatbuffers::Offset<SynFlatBuffers::Interface::Time> time) {
    fbb_.AddOffset(State::VT_TIME, time);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Interface::Type state_type = SynFlatBuffers::Interface::Type_NONE,
    flatbuffers::Offset<void> state = 0,
    flatbuffers::Offset<SynFlatBuffers::Interface::Time> time = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_state(state);
  builder_.add_state_type(state_type);
  return builder_.Finish();
}

struct Camera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_WIDTH = 6,
    VT_BYTES_PER_PIXEL = 8,
    VT_DATA = 10
  };
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t bytes_per_pixel() const {
    return GetField<int32_t>(VT_BYTES_PER_PIXEL, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_BYTES_PER_PIXEL) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct CameraBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(Camera::VT_HEIGHT, height, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Camera::VT_WIDTH, width, 0);
  }
  void add_bytes_per_pixel(int32_t bytes_per_pixel) {
    fbb_.AddElement<int32_t>(Camera::VT_BYTES_PER_PIXEL, bytes_per_pixel, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Camera::VT_DATA, data);
  }
  explicit CameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CameraBuilder &operator=(const CameraBuilder &);
  flatbuffers::Offset<Camera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Camera>(end);
    return o;
  }
};

inline flatbuffers::Offset<Camera> CreateCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    int32_t bytes_per_pixel = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  CameraBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_bytes_per_pixel(bytes_per_pixel);
  builder_.add_width(width);
  builder_.add_height(height);
  return builder_.Finish();
}

inline flatbuffers::Offset<Camera> CreateCameraDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    int32_t bytes_per_pixel = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return SynFlatBuffers::Interface::CreateCamera(
      _fbb,
      height,
      width,
      bytes_per_pixel,
      data__);
}

struct Lidar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTES_PER_PIXEL = 4,
    VT_DATA = 6
  };
  int32_t bytes_per_pixel() const {
    return GetField<int32_t>(VT_BYTES_PER_PIXEL, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BYTES_PER_PIXEL) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct LidarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bytes_per_pixel(int32_t bytes_per_pixel) {
    fbb_.AddElement<int32_t>(Lidar::VT_BYTES_PER_PIXEL, bytes_per_pixel, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Lidar::VT_DATA, data);
  }
  explicit LidarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LidarBuilder &operator=(const LidarBuilder &);
  flatbuffers::Offset<Lidar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lidar>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lidar> CreateLidar(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bytes_per_pixel = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  LidarBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_bytes_per_pixel(bytes_per_pixel);
  return builder_.Finish();
}

inline flatbuffers::Offset<Lidar> CreateLidarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bytes_per_pixel = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return SynFlatBuffers::Interface::CreateLidar(
      _fbb,
      bytes_per_pixel,
      data__);
}

struct GPS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GPSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GPSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GPSBuilder &operator=(const GPSBuilder &);
  flatbuffers::Offset<GPS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GPS>(end);
    return o;
  }
};

inline flatbuffers::Offset<GPS> CreateGPS(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GPSBuilder builder_(_fbb);
  return builder_.Finish();
}

struct IMU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct IMUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IMUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IMUBuilder &operator=(const IMUBuilder &);
  flatbuffers::Offset<IMU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IMU>(end);
    return o;
  }
};

inline flatbuffers::Offset<IMU> CreateIMU(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IMUBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Control FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THROTTLE = 4,
    VT_BRAKING = 6,
    VT_STEERING = 8
  };
  float throttle() const {
    return GetField<float>(VT_THROTTLE, 0.0f);
  }
  float braking() const {
    return GetField<float>(VT_BRAKING, 0.0f);
  }
  float steering() const {
    return GetField<float>(VT_STEERING, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_THROTTLE) &&
           VerifyField<float>(verifier, VT_BRAKING) &&
           VerifyField<float>(verifier, VT_STEERING) &&
           verifier.EndTable();
  }
};

struct ControlBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_throttle(float throttle) {
    fbb_.AddElement<float>(Control::VT_THROTTLE, throttle, 0.0f);
  }
  void add_braking(float braking) {
    fbb_.AddElement<float>(Control::VT_BRAKING, braking, 0.0f);
  }
  void add_steering(float steering) {
    fbb_.AddElement<float>(Control::VT_STEERING, steering, 0.0f);
  }
  explicit ControlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControlBuilder &operator=(const ControlBuilder &);
  flatbuffers::Offset<Control> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Control>(end);
    return o;
  }
};

inline flatbuffers::Offset<Control> CreateControl(
    flatbuffers::FlatBufferBuilder &_fbb,
    float throttle = 0.0f,
    float braking = 0.0f,
    float steering = 0.0f) {
  ControlBuilder builder_(_fbb);
  builder_.add_steering(steering);
  builder_.add_braking(braking);
  builder_.add_throttle(throttle);
  return builder_.Finish();
}

struct Time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  float t() const {
    return GetField<float>(VT_T, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_T) &&
           verifier.EndTable();
  }
};

struct TimeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_t(float t) {
    fbb_.AddElement<float>(Time::VT_T, t, 0.0f);
  }
  explicit TimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeBuilder &operator=(const TimeBuilder &);
  flatbuffers::Offset<Time> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Time>(end);
    return o;
  }
};

inline flatbuffers::Offset<Time> CreateTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    float t = 0.0f) {
  TimeBuilder builder_(_fbb);
  builder_.add_t(t);
  return builder_.Finish();
}

struct Exit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           verifier.EndTable();
  }
};

struct ExitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(Exit::VT_CODE, code, 0);
  }
  explicit ExitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExitBuilder &operator=(const ExitBuilder &);
  flatbuffers::Offset<Exit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exit> CreateExit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0) {
  ExitBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

}  // namespace Interface

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>> *buffer() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.VerifyVectorOfTables(buffer()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>>> buffer) {
    fbb_.AddOffset(Buffer::VT_BUFFER, buffer);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferBuilder &operator=(const BufferBuilder &);
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>>> buffer = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Message>> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Message>>(*buffer) : 0;
  return SynFlatBuffers::CreateBuffer(
      _fbb,
      buffer__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
    VT_ID = 8
  };
  SynFlatBuffers::Type message_type() const {
    return static_cast<SynFlatBuffers::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const SynFlatBuffers::Pointer *message_as_Pointer() const {
    return message_type() == SynFlatBuffers::Type_Pointer ? static_cast<const SynFlatBuffers::Pointer *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::State *message_as_Agent_State() const {
    return message_type() == SynFlatBuffers::Type_Agent_State ? static_cast<const SynFlatBuffers::Agent::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Interface::State *message_as_Interface_State() const {
    return message_type() == SynFlatBuffers::Type_Interface_State ? static_cast<const SynFlatBuffers::Interface::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::SPAT::State *message_as_SPAT_State() const {
    return message_type() == SynFlatBuffers::Type_SPAT_State ? static_cast<const SynFlatBuffers::SPAT::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::MAP::State *message_as_MAP_State() const {
    return message_type() == SynFlatBuffers::Type_MAP_State ? static_cast<const SynFlatBuffers::MAP::State *>(message()) : nullptr;
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Pointer *Message::message_as<SynFlatBuffers::Pointer>() const {
  return message_as_Pointer();
}

template<> inline const SynFlatBuffers::Agent::State *Message::message_as<SynFlatBuffers::Agent::State>() const {
  return message_as_Agent_State();
}

template<> inline const SynFlatBuffers::Interface::State *Message::message_as<SynFlatBuffers::Interface::State>() const {
  return message_as_Interface_State();
}

template<> inline const SynFlatBuffers::SPAT::State *Message::message_as<SynFlatBuffers::SPAT::State>() const {
  return message_as_SPAT_State();
}

template<> inline const SynFlatBuffers::MAP::State *Message::message_as<SynFlatBuffers::MAP::State>() const {
  return message_as_MAP_State();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(SynFlatBuffers::Type message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Message::VT_ID, id);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Type message_type = SynFlatBuffers::Type_NONE,
    flatbuffers::Offset<void> message = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Type message_type = SynFlatBuffers::Type_NONE,
    flatbuffers::Offset<void> message = 0,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return SynFlatBuffers::CreateMessage(
      _fbb,
      message_type,
      message,
      id__);
}

struct Pointer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTER = 4
  };
  const flatbuffers::Vector<uint8_t> *pointer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_POINTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTER) &&
           verifier.VerifyVector(pointer()) &&
           verifier.EndTable();
  }
};

struct PointerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pointer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pointer) {
    fbb_.AddOffset(Pointer::VT_POINTER, pointer);
  }
  explicit PointerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PointerBuilder &operator=(const PointerBuilder &);
  flatbuffers::Offset<Pointer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pointer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pointer> CreatePointer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pointer = 0) {
  PointerBuilder builder_(_fbb);
  builder_.add_pointer(pointer);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pointer> CreatePointerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *pointer = nullptr) {
  auto pointer__ = pointer ? _fbb.CreateVector<uint8_t>(*pointer) : 0;
  return SynFlatBuffers::CreatePointer(
      _fbb,
      pointer__);
}

namespace SPAT {

}  // namespace SPAT

namespace MAP {

}  // namespace MAP

namespace Agent {
namespace TrafficLight {

}  // namespace TrafficLight

namespace Sedan {

}  // namespace Sedan

}  // namespace Agent

namespace Interface {

}  // namespace Interface

namespace Agent {

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Sedan_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::Sedan::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_TrafficLight_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::TrafficLight::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Agent

namespace Interface {

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Camera: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::Camera *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Lidar: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::Lidar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GPS: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::GPS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_IMU: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::IMU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Control: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::Control *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Time: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::Time *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Exit: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::Exit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Interface

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Pointer: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Pointer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Agent_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Interface_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Interface::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_SPAT_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::SPAT::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_MAP_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::MAP::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const SynFlatBuffers::Buffer *GetBuffer(const void *buf) {
  return flatbuffers::GetRoot<SynFlatBuffers::Buffer>(buf);
}

inline const SynFlatBuffers::Buffer *GetSizePrefixedBuffer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SynFlatBuffers::Buffer>(buf);
}

inline bool VerifyBufferBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SynFlatBuffers::Buffer>(nullptr);
}

inline bool VerifySizePrefixedBufferBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SynFlatBuffers::Buffer>(nullptr);
}

inline void FinishBufferBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SynFlatBuffers::Buffer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBufferBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SynFlatBuffers::Buffer> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace SynFlatBuffers

#endif  // FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_
