// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHROSMESSAGES_CHROSMESSAGE_H_
#define FLATBUFFERS_GENERATED_CHROSMESSAGES_CHROSMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

namespace ChRosMessage {

struct Vector;

struct Color;

struct Header;

struct Message;

struct Config;

struct Lidar;

struct Camera;

struct GPS;

struct IMU;

struct Vehicle;

struct Control;

struct Time;

struct Cones;

struct Exit;

enum Type {
  Type_NONE = 0,
  Type_Lidar = 1,
  Type_Camera = 2,
  Type_GPS = 3,
  Type_IMU = 4,
  Type_Control = 5,
  Type_Time = 6,
  Type_Vehicle = 7,
  Type_Cones = 8,
  Type_Exit = 9,
  Type_Config = 10,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Config
};

inline const Type (&EnumValuesType())[11] {
  static const Type values[] = {
    Type_NONE,
    Type_Lidar,
    Type_Camera,
    Type_GPS,
    Type_IMU,
    Type_Control,
    Type_Time,
    Type_Vehicle,
    Type_Cones,
    Type_Exit,
    Type_Config
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[12] = {
    "NONE",
    "Lidar",
    "Camera",
    "GPS",
    "IMU",
    "Control",
    "Time",
    "Vehicle",
    "Cones",
    "Exit",
    "Config",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_Config) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<ChRosMessage::Lidar> {
  static const Type enum_value = Type_Lidar;
};

template<> struct TypeTraits<ChRosMessage::Camera> {
  static const Type enum_value = Type_Camera;
};

template<> struct TypeTraits<ChRosMessage::GPS> {
  static const Type enum_value = Type_GPS;
};

template<> struct TypeTraits<ChRosMessage::IMU> {
  static const Type enum_value = Type_IMU;
};

template<> struct TypeTraits<ChRosMessage::Control> {
  static const Type enum_value = Type_Control;
};

template<> struct TypeTraits<ChRosMessage::Time> {
  static const Type enum_value = Type_Time;
};

template<> struct TypeTraits<ChRosMessage::Vehicle> {
  static const Type enum_value = Type_Vehicle;
};

template<> struct TypeTraits<ChRosMessage::Cones> {
  static const Type enum_value = Type_Cones;
};

template<> struct TypeTraits<ChRosMessage::Exit> {
  static const Type enum_value = Type_Exit;
};

template<> struct TypeTraits<ChRosMessage::Config> {
  static const Type enum_value = Type_Config;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector() {
    memset(static_cast<void *>(this), 0, sizeof(Vector));
  }
  Vector(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t r_;
  int8_t g_;
  int8_t b_;
  int8_t a_;

 public:
  Color() {
    memset(static_cast<void *>(this), 0, sizeof(Color));
  }
  Color(int8_t _r, int8_t _g, int8_t _b, int8_t _a)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  int8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  int8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  int8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
  int8_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Header FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t size_;

 public:
  Header() {
    memset(static_cast<void *>(this), 0, sizeof(Header));
  }
  Header(int32_t _size)
      : size_(flatbuffers::EndianScalar(_size)) {
  }
  int32_t size() const {
    return flatbuffers::EndianScalar(size_);
  }
};
FLATBUFFERS_STRUCT_END(Header, 4);

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  ChRosMessage::Type message_type() const {
    return static_cast<ChRosMessage::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const ChRosMessage::Lidar *message_as_Lidar() const {
    return message_type() == ChRosMessage::Type_Lidar ? static_cast<const ChRosMessage::Lidar *>(message()) : nullptr;
  }
  const ChRosMessage::Camera *message_as_Camera() const {
    return message_type() == ChRosMessage::Type_Camera ? static_cast<const ChRosMessage::Camera *>(message()) : nullptr;
  }
  const ChRosMessage::GPS *message_as_GPS() const {
    return message_type() == ChRosMessage::Type_GPS ? static_cast<const ChRosMessage::GPS *>(message()) : nullptr;
  }
  const ChRosMessage::IMU *message_as_IMU() const {
    return message_type() == ChRosMessage::Type_IMU ? static_cast<const ChRosMessage::IMU *>(message()) : nullptr;
  }
  const ChRosMessage::Control *message_as_Control() const {
    return message_type() == ChRosMessage::Type_Control ? static_cast<const ChRosMessage::Control *>(message()) : nullptr;
  }
  const ChRosMessage::Time *message_as_Time() const {
    return message_type() == ChRosMessage::Type_Time ? static_cast<const ChRosMessage::Time *>(message()) : nullptr;
  }
  const ChRosMessage::Vehicle *message_as_Vehicle() const {
    return message_type() == ChRosMessage::Type_Vehicle ? static_cast<const ChRosMessage::Vehicle *>(message()) : nullptr;
  }
  const ChRosMessage::Cones *message_as_Cones() const {
    return message_type() == ChRosMessage::Type_Cones ? static_cast<const ChRosMessage::Cones *>(message()) : nullptr;
  }
  const ChRosMessage::Exit *message_as_Exit() const {
    return message_type() == ChRosMessage::Type_Exit ? static_cast<const ChRosMessage::Exit *>(message()) : nullptr;
  }
  const ChRosMessage::Config *message_as_Config() const {
    return message_type() == ChRosMessage::Type_Config ? static_cast<const ChRosMessage::Config *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ChRosMessage::Lidar *Message::message_as<ChRosMessage::Lidar>() const {
  return message_as_Lidar();
}

template<> inline const ChRosMessage::Camera *Message::message_as<ChRosMessage::Camera>() const {
  return message_as_Camera();
}

template<> inline const ChRosMessage::GPS *Message::message_as<ChRosMessage::GPS>() const {
  return message_as_GPS();
}

template<> inline const ChRosMessage::IMU *Message::message_as<ChRosMessage::IMU>() const {
  return message_as_IMU();
}

template<> inline const ChRosMessage::Control *Message::message_as<ChRosMessage::Control>() const {
  return message_as_Control();
}

template<> inline const ChRosMessage::Time *Message::message_as<ChRosMessage::Time>() const {
  return message_as_Time();
}

template<> inline const ChRosMessage::Vehicle *Message::message_as<ChRosMessage::Vehicle>() const {
  return message_as_Vehicle();
}

template<> inline const ChRosMessage::Cones *Message::message_as<ChRosMessage::Cones>() const {
  return message_as_Cones();
}

template<> inline const ChRosMessage::Exit *Message::message_as<ChRosMessage::Exit>() const {
  return message_as_Exit();
}

template<> inline const ChRosMessage::Config *Message::message_as<ChRosMessage::Config>() const {
  return message_as_Config();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(ChRosMessage::Type message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    ChRosMessage::Type message_type = ChRosMessage::Type_NONE,
    flatbuffers::Offset<void> message = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct Config FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_IRRLICHT = 4
  };
  bool use_irrlicht() const {
    return GetField<uint8_t>(VT_USE_IRRLICHT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_IRRLICHT) &&
           verifier.EndTable();
  }
};

struct ConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_use_irrlicht(bool use_irrlicht) {
    fbb_.AddElement<uint8_t>(Config::VT_USE_IRRLICHT, static_cast<uint8_t>(use_irrlicht), 0);
  }
  explicit ConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConfigBuilder &operator=(const ConfigBuilder &);
  flatbuffers::Offset<Config> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Config>(end);
    return o;
  }
};

inline flatbuffers::Offset<Config> CreateConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool use_irrlicht = false) {
  ConfigBuilder builder_(_fbb);
  builder_.add_use_irrlicht(use_irrlicht);
  return builder_.Finish();
}

struct Lidar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4
  };
  const flatbuffers::Vector<const ChRosMessage::Vector *> *points() const {
    return GetPointer<const flatbuffers::Vector<const ChRosMessage::Vector *> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct LidarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const ChRosMessage::Vector *>> points) {
    fbb_.AddOffset(Lidar::VT_POINTS, points);
  }
  explicit LidarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LidarBuilder &operator=(const LidarBuilder &);
  flatbuffers::Offset<Lidar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lidar>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lidar> CreateLidar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const ChRosMessage::Vector *>> points = 0) {
  LidarBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

inline flatbuffers::Offset<Lidar> CreateLidarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<ChRosMessage::Vector> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<ChRosMessage::Vector>(*points) : 0;
  return ChRosMessage::CreateLidar(
      _fbb,
      points__);
}

struct Camera FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_WIDTH = 6,
    VT_BYTES_PER_PIXEL = 8,
    VT_POINTS = 10
  };
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t bytes_per_pixel() const {
    return GetField<int32_t>(VT_BYTES_PER_PIXEL, 0);
  }
  const flatbuffers::Vector<uint8_t> *points() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_BYTES_PER_PIXEL) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct CameraBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(Camera::VT_HEIGHT, height, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Camera::VT_WIDTH, width, 0);
  }
  void add_bytes_per_pixel(int32_t bytes_per_pixel) {
    fbb_.AddElement<int32_t>(Camera::VT_BYTES_PER_PIXEL, bytes_per_pixel, 0);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> points) {
    fbb_.AddOffset(Camera::VT_POINTS, points);
  }
  explicit CameraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CameraBuilder &operator=(const CameraBuilder &);
  flatbuffers::Offset<Camera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Camera>(end);
    return o;
  }
};

inline flatbuffers::Offset<Camera> CreateCamera(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    int32_t bytes_per_pixel = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> points = 0) {
  CameraBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_bytes_per_pixel(bytes_per_pixel);
  builder_.add_width(width);
  builder_.add_height(height);
  return builder_.Finish();
}

inline flatbuffers::Offset<Camera> CreateCameraDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    int32_t bytes_per_pixel = 0,
    const std::vector<uint8_t> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVector<uint8_t>(*points) : 0;
  return ChRosMessage::CreateCamera(
      _fbb,
      height,
      width,
      bytes_per_pixel,
      points__);
}

struct GPS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDE = 4,
    VT_LATITUDE = 6,
    VT_ALTITUDE = 8
  };
  float longitude() const {
    return GetField<float>(VT_LONGITUDE, 0.0f);
  }
  float latitude() const {
    return GetField<float>(VT_LATITUDE, 0.0f);
  }
  float altitude() const {
    return GetField<float>(VT_ALTITUDE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LONGITUDE) &&
           VerifyField<float>(verifier, VT_LATITUDE) &&
           VerifyField<float>(verifier, VT_ALTITUDE) &&
           verifier.EndTable();
  }
};

struct GPSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_longitude(float longitude) {
    fbb_.AddElement<float>(GPS::VT_LONGITUDE, longitude, 0.0f);
  }
  void add_latitude(float latitude) {
    fbb_.AddElement<float>(GPS::VT_LATITUDE, latitude, 0.0f);
  }
  void add_altitude(float altitude) {
    fbb_.AddElement<float>(GPS::VT_ALTITUDE, altitude, 0.0f);
  }
  explicit GPSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GPSBuilder &operator=(const GPSBuilder &);
  flatbuffers::Offset<GPS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GPS>(end);
    return o;
  }
};

inline flatbuffers::Offset<GPS> CreateGPS(
    flatbuffers::FlatBufferBuilder &_fbb,
    float longitude = 0.0f,
    float latitude = 0.0f,
    float altitude = 0.0f) {
  GPSBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_latitude(latitude);
  builder_.add_longitude(longitude);
  return builder_.Finish();
}

struct IMU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANGULAR_VELOCITY = 4,
    VT_LINEAR_ACCELERATION = 6,
    VT_ORIENTATION = 8
  };
  const ChRosMessage::Vector *angular_velocity() const {
    return GetStruct<const ChRosMessage::Vector *>(VT_ANGULAR_VELOCITY);
  }
  const ChRosMessage::Vector *linear_acceleration() const {
    return GetStruct<const ChRosMessage::Vector *>(VT_LINEAR_ACCELERATION);
  }
  const ChRosMessage::Vector *orientation() const {
    return GetStruct<const ChRosMessage::Vector *>(VT_ORIENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ChRosMessage::Vector>(verifier, VT_ANGULAR_VELOCITY) &&
           VerifyField<ChRosMessage::Vector>(verifier, VT_LINEAR_ACCELERATION) &&
           VerifyField<ChRosMessage::Vector>(verifier, VT_ORIENTATION) &&
           verifier.EndTable();
  }
};

struct IMUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_angular_velocity(const ChRosMessage::Vector *angular_velocity) {
    fbb_.AddStruct(IMU::VT_ANGULAR_VELOCITY, angular_velocity);
  }
  void add_linear_acceleration(const ChRosMessage::Vector *linear_acceleration) {
    fbb_.AddStruct(IMU::VT_LINEAR_ACCELERATION, linear_acceleration);
  }
  void add_orientation(const ChRosMessage::Vector *orientation) {
    fbb_.AddStruct(IMU::VT_ORIENTATION, orientation);
  }
  explicit IMUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IMUBuilder &operator=(const IMUBuilder &);
  flatbuffers::Offset<IMU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IMU>(end);
    return o;
  }
};

inline flatbuffers::Offset<IMU> CreateIMU(
    flatbuffers::FlatBufferBuilder &_fbb,
    const ChRosMessage::Vector *angular_velocity = 0,
    const ChRosMessage::Vector *linear_acceleration = 0,
    const ChRosMessage::Vector *orientation = 0) {
  IMUBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_linear_acceleration(linear_acceleration);
  builder_.add_angular_velocity(angular_velocity);
  return builder_.Finish();
}

struct Vehicle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_VELOCITY = 6,
    VT_ACCELERATION = 8
  };
  const ChRosMessage::Vector *position() const {
    return GetStruct<const ChRosMessage::Vector *>(VT_POSITION);
  }
  const ChRosMessage::Vector *velocity() const {
    return GetStruct<const ChRosMessage::Vector *>(VT_VELOCITY);
  }
  const ChRosMessage::Vector *acceleration() const {
    return GetStruct<const ChRosMessage::Vector *>(VT_ACCELERATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ChRosMessage::Vector>(verifier, VT_POSITION) &&
           VerifyField<ChRosMessage::Vector>(verifier, VT_VELOCITY) &&
           VerifyField<ChRosMessage::Vector>(verifier, VT_ACCELERATION) &&
           verifier.EndTable();
  }
};

struct VehicleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const ChRosMessage::Vector *position) {
    fbb_.AddStruct(Vehicle::VT_POSITION, position);
  }
  void add_velocity(const ChRosMessage::Vector *velocity) {
    fbb_.AddStruct(Vehicle::VT_VELOCITY, velocity);
  }
  void add_acceleration(const ChRosMessage::Vector *acceleration) {
    fbb_.AddStruct(Vehicle::VT_ACCELERATION, acceleration);
  }
  explicit VehicleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VehicleBuilder &operator=(const VehicleBuilder &);
  flatbuffers::Offset<Vehicle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vehicle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vehicle> CreateVehicle(
    flatbuffers::FlatBufferBuilder &_fbb,
    const ChRosMessage::Vector *position = 0,
    const ChRosMessage::Vector *velocity = 0,
    const ChRosMessage::Vector *acceleration = 0) {
  VehicleBuilder builder_(_fbb);
  builder_.add_acceleration(acceleration);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  return builder_.Finish();
}

struct Control FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THROTTLE = 4,
    VT_STEERING = 6,
    VT_BRAKING = 8
  };
  float throttle() const {
    return GetField<float>(VT_THROTTLE, 0.0f);
  }
  float steering() const {
    return GetField<float>(VT_STEERING, 0.0f);
  }
  float braking() const {
    return GetField<float>(VT_BRAKING, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_THROTTLE) &&
           VerifyField<float>(verifier, VT_STEERING) &&
           VerifyField<float>(verifier, VT_BRAKING) &&
           verifier.EndTable();
  }
};

struct ControlBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_throttle(float throttle) {
    fbb_.AddElement<float>(Control::VT_THROTTLE, throttle, 0.0f);
  }
  void add_steering(float steering) {
    fbb_.AddElement<float>(Control::VT_STEERING, steering, 0.0f);
  }
  void add_braking(float braking) {
    fbb_.AddElement<float>(Control::VT_BRAKING, braking, 0.0f);
  }
  explicit ControlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControlBuilder &operator=(const ControlBuilder &);
  flatbuffers::Offset<Control> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Control>(end);
    return o;
  }
};

inline flatbuffers::Offset<Control> CreateControl(
    flatbuffers::FlatBufferBuilder &_fbb,
    float throttle = 0.0f,
    float steering = 0.0f,
    float braking = 0.0f) {
  ControlBuilder builder_(_fbb);
  builder_.add_braking(braking);
  builder_.add_steering(steering);
  builder_.add_throttle(throttle);
  return builder_.Finish();
}

struct Time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  float t() const {
    return GetField<float>(VT_T, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_T) &&
           verifier.EndTable();
  }
};

struct TimeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_t(float t) {
    fbb_.AddElement<float>(Time::VT_T, t, 0.0f);
  }
  explicit TimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeBuilder &operator=(const TimeBuilder &);
  flatbuffers::Offset<Time> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Time>(end);
    return o;
  }
};

inline flatbuffers::Offset<Time> CreateTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    float t = 0.0f) {
  TimeBuilder builder_(_fbb);
  builder_.add_t(t);
  return builder_.Finish();
}

struct Cones FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLUE_CONES = 4,
    VT_YELLOW_CONES = 6
  };
  const flatbuffers::Vector<const ChRosMessage::Vector *> *blue_cones() const {
    return GetPointer<const flatbuffers::Vector<const ChRosMessage::Vector *> *>(VT_BLUE_CONES);
  }
  const flatbuffers::Vector<const ChRosMessage::Vector *> *yellow_cones() const {
    return GetPointer<const flatbuffers::Vector<const ChRosMessage::Vector *> *>(VT_YELLOW_CONES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLUE_CONES) &&
           verifier.VerifyVector(blue_cones()) &&
           VerifyOffset(verifier, VT_YELLOW_CONES) &&
           verifier.VerifyVector(yellow_cones()) &&
           verifier.EndTable();
  }
};

struct ConesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blue_cones(flatbuffers::Offset<flatbuffers::Vector<const ChRosMessage::Vector *>> blue_cones) {
    fbb_.AddOffset(Cones::VT_BLUE_CONES, blue_cones);
  }
  void add_yellow_cones(flatbuffers::Offset<flatbuffers::Vector<const ChRosMessage::Vector *>> yellow_cones) {
    fbb_.AddOffset(Cones::VT_YELLOW_CONES, yellow_cones);
  }
  explicit ConesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConesBuilder &operator=(const ConesBuilder &);
  flatbuffers::Offset<Cones> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cones>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cones> CreateCones(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const ChRosMessage::Vector *>> blue_cones = 0,
    flatbuffers::Offset<flatbuffers::Vector<const ChRosMessage::Vector *>> yellow_cones = 0) {
  ConesBuilder builder_(_fbb);
  builder_.add_yellow_cones(yellow_cones);
  builder_.add_blue_cones(blue_cones);
  return builder_.Finish();
}

inline flatbuffers::Offset<Cones> CreateConesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<ChRosMessage::Vector> *blue_cones = nullptr,
    const std::vector<ChRosMessage::Vector> *yellow_cones = nullptr) {
  auto blue_cones__ = blue_cones ? _fbb.CreateVectorOfStructs<ChRosMessage::Vector>(*blue_cones) : 0;
  auto yellow_cones__ = yellow_cones ? _fbb.CreateVectorOfStructs<ChRosMessage::Vector>(*yellow_cones) : 0;
  return ChRosMessage::CreateCones(
      _fbb,
      blue_cones__,
      yellow_cones__);
}

struct Exit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4
  };
  int8_t code() const {
    return GetField<int8_t>(VT_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CODE) &&
           verifier.EndTable();
  }
};

struct ExitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int8_t code) {
    fbb_.AddElement<int8_t>(Exit::VT_CODE, code, 0);
  }
  explicit ExitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExitBuilder &operator=(const ExitBuilder &);
  flatbuffers::Offset<Exit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exit> CreateExit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t code = 0) {
  ExitBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Lidar: {
      auto ptr = reinterpret_cast<const ChRosMessage::Lidar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Camera: {
      auto ptr = reinterpret_cast<const ChRosMessage::Camera *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_GPS: {
      auto ptr = reinterpret_cast<const ChRosMessage::GPS *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_IMU: {
      auto ptr = reinterpret_cast<const ChRosMessage::IMU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Control: {
      auto ptr = reinterpret_cast<const ChRosMessage::Control *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Time: {
      auto ptr = reinterpret_cast<const ChRosMessage::Time *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Vehicle: {
      auto ptr = reinterpret_cast<const ChRosMessage::Vehicle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Cones: {
      auto ptr = reinterpret_cast<const ChRosMessage::Cones *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Exit: {
      auto ptr = reinterpret_cast<const ChRosMessage::Exit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Config: {
      auto ptr = reinterpret_cast<const ChRosMessage::Config *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace ChRosMessage

#endif  // FLATBUFFERS_GENERATED_CHROSMESSAGES_CHROSMESSAGE_H_
