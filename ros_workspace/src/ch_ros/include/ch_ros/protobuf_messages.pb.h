// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protobuf_messages.proto

#ifndef PROTOBUF_protobuf_5fmessages_2eproto__INCLUDED
#define PROTOBUF_protobuf_5fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ChronoMessages {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protobuf_5fmessages_2eproto();
void protobuf_AssignDesc_protobuf_5fmessages_2eproto();
void protobuf_ShutdownFile_protobuf_5fmessages_2eproto();

class Vector;
class cones;
class control;
class exit;
class gps;
class imu;
class lidar;
class time;
class vehicle;

// ===================================================================

class Vector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChronoMessages.Vector) */ {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();

  void Swap(Vector* other);

  // implements Message ----------------------------------------------

  inline Vector* New() const { return New(NULL); }

  Vector* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:ChronoMessages.Vector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_AssignDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_protobuf_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// -------------------------------------------------------------------

class lidar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChronoMessages.lidar) */ {
 public:
  lidar();
  virtual ~lidar();

  lidar(const lidar& from);

  inline lidar& operator=(const lidar& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lidar& default_instance();

  void Swap(lidar* other);

  // implements Message ----------------------------------------------

  inline lidar* New() const { return New(NULL); }

  lidar* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lidar& from);
  void MergeFrom(const lidar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(lidar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ChronoMessages.Vector points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::ChronoMessages::Vector& points(int index) const;
  ::ChronoMessages::Vector* mutable_points(int index);
  ::ChronoMessages::Vector* add_points();
  ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >&
      points() const;

  // optional int32 num = 2;
  void clear_num();
  static const int kNumFieldNumber = 2;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // optional int32 expected = 3;
  void clear_expected();
  static const int kExpectedFieldNumber = 3;
  ::google::protobuf::int32 expected() const;
  void set_expected(::google::protobuf::int32 value);

  // optional int32 id = 4;
  void clear_id();
  static const int kIdFieldNumber = 4;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ChronoMessages.lidar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector > points_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 expected_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_AssignDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_protobuf_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static lidar* default_instance_;
};
// -------------------------------------------------------------------

class gps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChronoMessages.gps) */ {
 public:
  gps();
  virtual ~gps();

  gps(const gps& from);

  inline gps& operator=(const gps& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gps& default_instance();

  void Swap(gps* other);

  // implements Message ----------------------------------------------

  inline gps* New() const { return New(NULL); }

  gps* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gps& from);
  void MergeFrom(const gps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(gps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double longitude = 1;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  double longitude() const;
  void set_longitude(double value);

  // optional double latitude = 2;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  double latitude() const;
  void set_latitude(double value);

  // optional double altitude = 3;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  double altitude() const;
  void set_altitude(double value);

  // @@protoc_insertion_point(class_scope:ChronoMessages.gps)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double longitude_;
  double latitude_;
  double altitude_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_AssignDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_protobuf_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static gps* default_instance_;
};
// -------------------------------------------------------------------

class imu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChronoMessages.imu) */ {
 public:
  imu();
  virtual ~imu();

  imu(const imu& from);

  inline imu& operator=(const imu& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const imu& default_instance();

  void Swap(imu* other);

  // implements Message ----------------------------------------------

  inline imu* New() const { return New(NULL); }

  imu* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const imu& from);
  void MergeFrom(const imu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(imu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ChronoMessages.Vector angular_velocity = 1;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 1;
  const ::ChronoMessages::Vector& angular_velocity() const;
  ::ChronoMessages::Vector* mutable_angular_velocity();
  ::ChronoMessages::Vector* release_angular_velocity();
  void set_allocated_angular_velocity(::ChronoMessages::Vector* angular_velocity);

  // optional .ChronoMessages.Vector linear_acceleration = 2;
  bool has_linear_acceleration() const;
  void clear_linear_acceleration();
  static const int kLinearAccelerationFieldNumber = 2;
  const ::ChronoMessages::Vector& linear_acceleration() const;
  ::ChronoMessages::Vector* mutable_linear_acceleration();
  ::ChronoMessages::Vector* release_linear_acceleration();
  void set_allocated_linear_acceleration(::ChronoMessages::Vector* linear_acceleration);

  // optional .ChronoMessages.Vector orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  const ::ChronoMessages::Vector& orientation() const;
  ::ChronoMessages::Vector* mutable_orientation();
  ::ChronoMessages::Vector* release_orientation();
  void set_allocated_orientation(::ChronoMessages::Vector* orientation);

  // @@protoc_insertion_point(class_scope:ChronoMessages.imu)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::ChronoMessages::Vector* angular_velocity_;
  ::ChronoMessages::Vector* linear_acceleration_;
  ::ChronoMessages::Vector* orientation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_AssignDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_protobuf_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static imu* default_instance_;
};
// -------------------------------------------------------------------

class control : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChronoMessages.control) */ {
 public:
  control();
  virtual ~control();

  control(const control& from);

  inline control& operator=(const control& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const control& default_instance();

  void Swap(control* other);

  // implements Message ----------------------------------------------

  inline control* New() const { return New(NULL); }

  control* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const control& from);
  void MergeFrom(const control& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(control* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double throttle = 1;
  void clear_throttle();
  static const int kThrottleFieldNumber = 1;
  double throttle() const;
  void set_throttle(double value);

  // optional double steering = 2;
  void clear_steering();
  static const int kSteeringFieldNumber = 2;
  double steering() const;
  void set_steering(double value);

  // optional double braking = 3;
  void clear_braking();
  static const int kBrakingFieldNumber = 3;
  double braking() const;
  void set_braking(double value);

  // @@protoc_insertion_point(class_scope:ChronoMessages.control)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double throttle_;
  double steering_;
  double braking_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_AssignDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_protobuf_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static control* default_instance_;
};
// -------------------------------------------------------------------

class time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChronoMessages.time) */ {
 public:
  time();
  virtual ~time();

  time(const time& from);

  inline time& operator=(const time& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const time& default_instance();

  void Swap(time* other);

  // implements Message ----------------------------------------------

  inline time* New() const { return New(NULL); }

  time* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const time& from);
  void MergeFrom(const time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double t = 1;
  void clear_t();
  static const int kTFieldNumber = 1;
  double t() const;
  void set_t(double value);

  // @@protoc_insertion_point(class_scope:ChronoMessages.time)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double t_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_AssignDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_protobuf_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static time* default_instance_;
};
// -------------------------------------------------------------------

class cones : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChronoMessages.cones) */ {
 public:
  cones();
  virtual ~cones();

  cones(const cones& from);

  inline cones& operator=(const cones& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cones& default_instance();

  void Swap(cones* other);

  // implements Message ----------------------------------------------

  inline cones* New() const { return New(NULL); }

  cones* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cones& from);
  void MergeFrom(const cones& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(cones* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ChronoMessages.Vector blue_cones = 1;
  int blue_cones_size() const;
  void clear_blue_cones();
  static const int kBlueConesFieldNumber = 1;
  const ::ChronoMessages::Vector& blue_cones(int index) const;
  ::ChronoMessages::Vector* mutable_blue_cones(int index);
  ::ChronoMessages::Vector* add_blue_cones();
  ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >*
      mutable_blue_cones();
  const ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >&
      blue_cones() const;

  // repeated .ChronoMessages.Vector yellow_cones = 2;
  int yellow_cones_size() const;
  void clear_yellow_cones();
  static const int kYellowConesFieldNumber = 2;
  const ::ChronoMessages::Vector& yellow_cones(int index) const;
  ::ChronoMessages::Vector* mutable_yellow_cones(int index);
  ::ChronoMessages::Vector* add_yellow_cones();
  ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >*
      mutable_yellow_cones();
  const ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >&
      yellow_cones() const;

  // @@protoc_insertion_point(class_scope:ChronoMessages.cones)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector > blue_cones_;
  ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector > yellow_cones_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_AssignDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_protobuf_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static cones* default_instance_;
};
// -------------------------------------------------------------------

class vehicle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChronoMessages.vehicle) */ {
 public:
  vehicle();
  virtual ~vehicle();

  vehicle(const vehicle& from);

  inline vehicle& operator=(const vehicle& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vehicle& default_instance();

  void Swap(vehicle* other);

  // implements Message ----------------------------------------------

  inline vehicle* New() const { return New(NULL); }

  vehicle* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vehicle& from);
  void MergeFrom(const vehicle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(vehicle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ChronoMessages.Vector position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::ChronoMessages::Vector& position() const;
  ::ChronoMessages::Vector* mutable_position();
  ::ChronoMessages::Vector* release_position();
  void set_allocated_position(::ChronoMessages::Vector* position);

  // optional .ChronoMessages.Vector velocity = 2;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  const ::ChronoMessages::Vector& velocity() const;
  ::ChronoMessages::Vector* mutable_velocity();
  ::ChronoMessages::Vector* release_velocity();
  void set_allocated_velocity(::ChronoMessages::Vector* velocity);

  // optional .ChronoMessages.Vector acceleration = 3;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 3;
  const ::ChronoMessages::Vector& acceleration() const;
  ::ChronoMessages::Vector* mutable_acceleration();
  ::ChronoMessages::Vector* release_acceleration();
  void set_allocated_acceleration(::ChronoMessages::Vector* acceleration);

  // @@protoc_insertion_point(class_scope:ChronoMessages.vehicle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::ChronoMessages::Vector* position_;
  ::ChronoMessages::Vector* velocity_;
  ::ChronoMessages::Vector* acceleration_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_AssignDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_protobuf_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static vehicle* default_instance_;
};
// -------------------------------------------------------------------

class exit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChronoMessages.exit) */ {
 public:
  exit();
  virtual ~exit();

  exit(const exit& from);

  inline exit& operator=(const exit& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exit& default_instance();

  void Swap(exit* other);

  // implements Message ----------------------------------------------

  inline exit* New() const { return New(NULL); }

  exit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exit& from);
  void MergeFrom(const exit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(exit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:ChronoMessages.exit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_AssignDesc_protobuf_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_protobuf_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static exit* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Vector

// optional float x = 1;
inline void Vector::clear_x() {
  x_ = 0;
}
inline float Vector::x() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.Vector.x)
  return x_;
}
inline void Vector::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.Vector.x)
}

// optional float y = 2;
inline void Vector::clear_y() {
  y_ = 0;
}
inline float Vector::y() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.Vector.y)
  return y_;
}
inline void Vector::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.Vector.y)
}

// optional float z = 3;
inline void Vector::clear_z() {
  z_ = 0;
}
inline float Vector::z() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.Vector.z)
  return z_;
}
inline void Vector::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.Vector.z)
}

// -------------------------------------------------------------------

// lidar

// repeated .ChronoMessages.Vector points = 1;
inline int lidar::points_size() const {
  return points_.size();
}
inline void lidar::clear_points() {
  points_.Clear();
}
inline const ::ChronoMessages::Vector& lidar::points(int index) const {
  // @@protoc_insertion_point(field_get:ChronoMessages.lidar.points)
  return points_.Get(index);
}
inline ::ChronoMessages::Vector* lidar::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:ChronoMessages.lidar.points)
  return points_.Mutable(index);
}
inline ::ChronoMessages::Vector* lidar::add_points() {
  // @@protoc_insertion_point(field_add:ChronoMessages.lidar.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >*
lidar::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:ChronoMessages.lidar.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >&
lidar::points() const {
  // @@protoc_insertion_point(field_list:ChronoMessages.lidar.points)
  return points_;
}

// optional int32 num = 2;
inline void lidar::clear_num() {
  num_ = 0;
}
inline ::google::protobuf::int32 lidar::num() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.lidar.num)
  return num_;
}
inline void lidar::set_num(::google::protobuf::int32 value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.lidar.num)
}

// optional int32 expected = 3;
inline void lidar::clear_expected() {
  expected_ = 0;
}
inline ::google::protobuf::int32 lidar::expected() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.lidar.expected)
  return expected_;
}
inline void lidar::set_expected(::google::protobuf::int32 value) {
  
  expected_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.lidar.expected)
}

// optional int32 id = 4;
inline void lidar::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 lidar::id() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.lidar.id)
  return id_;
}
inline void lidar::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.lidar.id)
}

// -------------------------------------------------------------------

// gps

// optional double longitude = 1;
inline void gps::clear_longitude() {
  longitude_ = 0;
}
inline double gps::longitude() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.gps.longitude)
  return longitude_;
}
inline void gps::set_longitude(double value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.gps.longitude)
}

// optional double latitude = 2;
inline void gps::clear_latitude() {
  latitude_ = 0;
}
inline double gps::latitude() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.gps.latitude)
  return latitude_;
}
inline void gps::set_latitude(double value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.gps.latitude)
}

// optional double altitude = 3;
inline void gps::clear_altitude() {
  altitude_ = 0;
}
inline double gps::altitude() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.gps.altitude)
  return altitude_;
}
inline void gps::set_altitude(double value) {
  
  altitude_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.gps.altitude)
}

// -------------------------------------------------------------------

// imu

// optional .ChronoMessages.Vector angular_velocity = 1;
inline bool imu::has_angular_velocity() const {
  return !_is_default_instance_ && angular_velocity_ != NULL;
}
inline void imu::clear_angular_velocity() {
  if (GetArenaNoVirtual() == NULL && angular_velocity_ != NULL) delete angular_velocity_;
  angular_velocity_ = NULL;
}
inline const ::ChronoMessages::Vector& imu::angular_velocity() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.imu.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_ : *default_instance_->angular_velocity_;
}
inline ::ChronoMessages::Vector* imu::mutable_angular_velocity() {
  
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::ChronoMessages::Vector;
  }
  // @@protoc_insertion_point(field_mutable:ChronoMessages.imu.angular_velocity)
  return angular_velocity_;
}
inline ::ChronoMessages::Vector* imu::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:ChronoMessages.imu.angular_velocity)
  
  ::ChronoMessages::Vector* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void imu::set_allocated_angular_velocity(::ChronoMessages::Vector* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ChronoMessages.imu.angular_velocity)
}

// optional .ChronoMessages.Vector linear_acceleration = 2;
inline bool imu::has_linear_acceleration() const {
  return !_is_default_instance_ && linear_acceleration_ != NULL;
}
inline void imu::clear_linear_acceleration() {
  if (GetArenaNoVirtual() == NULL && linear_acceleration_ != NULL) delete linear_acceleration_;
  linear_acceleration_ = NULL;
}
inline const ::ChronoMessages::Vector& imu::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.imu.linear_acceleration)
  return linear_acceleration_ != NULL ? *linear_acceleration_ : *default_instance_->linear_acceleration_;
}
inline ::ChronoMessages::Vector* imu::mutable_linear_acceleration() {
  
  if (linear_acceleration_ == NULL) {
    linear_acceleration_ = new ::ChronoMessages::Vector;
  }
  // @@protoc_insertion_point(field_mutable:ChronoMessages.imu.linear_acceleration)
  return linear_acceleration_;
}
inline ::ChronoMessages::Vector* imu::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:ChronoMessages.imu.linear_acceleration)
  
  ::ChronoMessages::Vector* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
inline void imu::set_allocated_linear_acceleration(::ChronoMessages::Vector* linear_acceleration) {
  delete linear_acceleration_;
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ChronoMessages.imu.linear_acceleration)
}

// optional .ChronoMessages.Vector orientation = 3;
inline bool imu::has_orientation() const {
  return !_is_default_instance_ && orientation_ != NULL;
}
inline void imu::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) delete orientation_;
  orientation_ = NULL;
}
inline const ::ChronoMessages::Vector& imu::orientation() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.imu.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::ChronoMessages::Vector* imu::mutable_orientation() {
  
  if (orientation_ == NULL) {
    orientation_ = new ::ChronoMessages::Vector;
  }
  // @@protoc_insertion_point(field_mutable:ChronoMessages.imu.orientation)
  return orientation_;
}
inline ::ChronoMessages::Vector* imu::release_orientation() {
  // @@protoc_insertion_point(field_release:ChronoMessages.imu.orientation)
  
  ::ChronoMessages::Vector* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void imu::set_allocated_orientation(::ChronoMessages::Vector* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ChronoMessages.imu.orientation)
}

// -------------------------------------------------------------------

// control

// optional double throttle = 1;
inline void control::clear_throttle() {
  throttle_ = 0;
}
inline double control::throttle() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.control.throttle)
  return throttle_;
}
inline void control::set_throttle(double value) {
  
  throttle_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.control.throttle)
}

// optional double steering = 2;
inline void control::clear_steering() {
  steering_ = 0;
}
inline double control::steering() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.control.steering)
  return steering_;
}
inline void control::set_steering(double value) {
  
  steering_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.control.steering)
}

// optional double braking = 3;
inline void control::clear_braking() {
  braking_ = 0;
}
inline double control::braking() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.control.braking)
  return braking_;
}
inline void control::set_braking(double value) {
  
  braking_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.control.braking)
}

// -------------------------------------------------------------------

// time

// optional double t = 1;
inline void time::clear_t() {
  t_ = 0;
}
inline double time::t() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.time.t)
  return t_;
}
inline void time::set_t(double value) {
  
  t_ = value;
  // @@protoc_insertion_point(field_set:ChronoMessages.time.t)
}

// -------------------------------------------------------------------

// cones

// repeated .ChronoMessages.Vector blue_cones = 1;
inline int cones::blue_cones_size() const {
  return blue_cones_.size();
}
inline void cones::clear_blue_cones() {
  blue_cones_.Clear();
}
inline const ::ChronoMessages::Vector& cones::blue_cones(int index) const {
  // @@protoc_insertion_point(field_get:ChronoMessages.cones.blue_cones)
  return blue_cones_.Get(index);
}
inline ::ChronoMessages::Vector* cones::mutable_blue_cones(int index) {
  // @@protoc_insertion_point(field_mutable:ChronoMessages.cones.blue_cones)
  return blue_cones_.Mutable(index);
}
inline ::ChronoMessages::Vector* cones::add_blue_cones() {
  // @@protoc_insertion_point(field_add:ChronoMessages.cones.blue_cones)
  return blue_cones_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >*
cones::mutable_blue_cones() {
  // @@protoc_insertion_point(field_mutable_list:ChronoMessages.cones.blue_cones)
  return &blue_cones_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >&
cones::blue_cones() const {
  // @@protoc_insertion_point(field_list:ChronoMessages.cones.blue_cones)
  return blue_cones_;
}

// repeated .ChronoMessages.Vector yellow_cones = 2;
inline int cones::yellow_cones_size() const {
  return yellow_cones_.size();
}
inline void cones::clear_yellow_cones() {
  yellow_cones_.Clear();
}
inline const ::ChronoMessages::Vector& cones::yellow_cones(int index) const {
  // @@protoc_insertion_point(field_get:ChronoMessages.cones.yellow_cones)
  return yellow_cones_.Get(index);
}
inline ::ChronoMessages::Vector* cones::mutable_yellow_cones(int index) {
  // @@protoc_insertion_point(field_mutable:ChronoMessages.cones.yellow_cones)
  return yellow_cones_.Mutable(index);
}
inline ::ChronoMessages::Vector* cones::add_yellow_cones() {
  // @@protoc_insertion_point(field_add:ChronoMessages.cones.yellow_cones)
  return yellow_cones_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >*
cones::mutable_yellow_cones() {
  // @@protoc_insertion_point(field_mutable_list:ChronoMessages.cones.yellow_cones)
  return &yellow_cones_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ChronoMessages::Vector >&
cones::yellow_cones() const {
  // @@protoc_insertion_point(field_list:ChronoMessages.cones.yellow_cones)
  return yellow_cones_;
}

// -------------------------------------------------------------------

// vehicle

// optional .ChronoMessages.Vector position = 1;
inline bool vehicle::has_position() const {
  return !_is_default_instance_ && position_ != NULL;
}
inline void vehicle::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) delete position_;
  position_ = NULL;
}
inline const ::ChronoMessages::Vector& vehicle::position() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.vehicle.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::ChronoMessages::Vector* vehicle::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::ChronoMessages::Vector;
  }
  // @@protoc_insertion_point(field_mutable:ChronoMessages.vehicle.position)
  return position_;
}
inline ::ChronoMessages::Vector* vehicle::release_position() {
  // @@protoc_insertion_point(field_release:ChronoMessages.vehicle.position)
  
  ::ChronoMessages::Vector* temp = position_;
  position_ = NULL;
  return temp;
}
inline void vehicle::set_allocated_position(::ChronoMessages::Vector* position) {
  delete position_;
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ChronoMessages.vehicle.position)
}

// optional .ChronoMessages.Vector velocity = 2;
inline bool vehicle::has_velocity() const {
  return !_is_default_instance_ && velocity_ != NULL;
}
inline void vehicle::clear_velocity() {
  if (GetArenaNoVirtual() == NULL && velocity_ != NULL) delete velocity_;
  velocity_ = NULL;
}
inline const ::ChronoMessages::Vector& vehicle::velocity() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.vehicle.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::ChronoMessages::Vector* vehicle::mutable_velocity() {
  
  if (velocity_ == NULL) {
    velocity_ = new ::ChronoMessages::Vector;
  }
  // @@protoc_insertion_point(field_mutable:ChronoMessages.vehicle.velocity)
  return velocity_;
}
inline ::ChronoMessages::Vector* vehicle::release_velocity() {
  // @@protoc_insertion_point(field_release:ChronoMessages.vehicle.velocity)
  
  ::ChronoMessages::Vector* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void vehicle::set_allocated_velocity(::ChronoMessages::Vector* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ChronoMessages.vehicle.velocity)
}

// optional .ChronoMessages.Vector acceleration = 3;
inline bool vehicle::has_acceleration() const {
  return !_is_default_instance_ && acceleration_ != NULL;
}
inline void vehicle::clear_acceleration() {
  if (GetArenaNoVirtual() == NULL && acceleration_ != NULL) delete acceleration_;
  acceleration_ = NULL;
}
inline const ::ChronoMessages::Vector& vehicle::acceleration() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.vehicle.acceleration)
  return acceleration_ != NULL ? *acceleration_ : *default_instance_->acceleration_;
}
inline ::ChronoMessages::Vector* vehicle::mutable_acceleration() {
  
  if (acceleration_ == NULL) {
    acceleration_ = new ::ChronoMessages::Vector;
  }
  // @@protoc_insertion_point(field_mutable:ChronoMessages.vehicle.acceleration)
  return acceleration_;
}
inline ::ChronoMessages::Vector* vehicle::release_acceleration() {
  // @@protoc_insertion_point(field_release:ChronoMessages.vehicle.acceleration)
  
  ::ChronoMessages::Vector* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline void vehicle::set_allocated_acceleration(::ChronoMessages::Vector* acceleration) {
  delete acceleration_;
  acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ChronoMessages.vehicle.acceleration)
}

// -------------------------------------------------------------------

// exit

// optional string code = 1;
inline void exit::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& exit::code() const {
  // @@protoc_insertion_point(field_get:ChronoMessages.exit.code)
  return code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void exit::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChronoMessages.exit.code)
}
inline void exit::set_code(const char* value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChronoMessages.exit.code)
}
inline void exit::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChronoMessages.exit.code)
}
inline ::std::string* exit::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:ChronoMessages.exit.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* exit::release_code() {
  // @@protoc_insertion_point(field_release:ChronoMessages.exit.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void exit::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:ChronoMessages.exit.code)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ChronoMessages

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protobuf_5fmessages_2eproto__INCLUDED
