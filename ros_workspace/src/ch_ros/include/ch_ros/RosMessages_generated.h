// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ROSMESSAGES_ROSMESSAGE_H_
#define FLATBUFFERS_GENERATED_ROSMESSAGES_ROSMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

namespace RosMessage {

struct Vector;

struct Header;

struct message;

struct lidar;

struct gps;

struct imu;

struct vehicle;

struct control;

struct time;

struct cones;

struct exit;

enum Type {
  Type_NONE = 0,
  Type_lidar = 1,
  Type_gps = 2,
  Type_imu = 3,
  Type_control = 4,
  Type_time = 5,
  Type_vehicle = 6,
  Type_cones = 7,
  Type_exit = 8,
  Type_MIN = Type_NONE,
  Type_MAX = Type_exit
};

inline const Type (&EnumValuesType())[9] {
  static const Type values[] = {
    Type_NONE,
    Type_lidar,
    Type_gps,
    Type_imu,
    Type_control,
    Type_time,
    Type_vehicle,
    Type_cones,
    Type_exit
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[10] = {
    "NONE",
    "lidar",
    "gps",
    "imu",
    "control",
    "time",
    "vehicle",
    "cones",
    "exit",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_exit) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<RosMessage::lidar> {
  static const Type enum_value = Type_lidar;
};

template<> struct TypeTraits<RosMessage::gps> {
  static const Type enum_value = Type_gps;
};

template<> struct TypeTraits<RosMessage::imu> {
  static const Type enum_value = Type_imu;
};

template<> struct TypeTraits<RosMessage::control> {
  static const Type enum_value = Type_control;
};

template<> struct TypeTraits<RosMessage::time> {
  static const Type enum_value = Type_time;
};

template<> struct TypeTraits<RosMessage::vehicle> {
  static const Type enum_value = Type_vehicle;
};

template<> struct TypeTraits<RosMessage::cones> {
  static const Type enum_value = Type_cones;
};

template<> struct TypeTraits<RosMessage::exit> {
  static const Type enum_value = Type_exit;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector() {
    memset(static_cast<void *>(this), 0, sizeof(Vector));
  }
  Vector(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Header FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t size_;

 public:
  Header() {
    memset(static_cast<void *>(this), 0, sizeof(Header));
  }
  Header(int32_t _size)
      : size_(flatbuffers::EndianScalar(_size)) {
  }
  int32_t size() const {
    return flatbuffers::EndianScalar(size_);
  }
};
FLATBUFFERS_STRUCT_END(Header, 4);

struct message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_TYPE = 4,
    VT_TYPE = 6
  };
  RosMessage::Type type_type() const {
    return static_cast<RosMessage::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *type_as() const;
  const RosMessage::lidar *type_as_lidar() const {
    return type_type() == RosMessage::Type_lidar ? static_cast<const RosMessage::lidar *>(type()) : nullptr;
  }
  const RosMessage::gps *type_as_gps() const {
    return type_type() == RosMessage::Type_gps ? static_cast<const RosMessage::gps *>(type()) : nullptr;
  }
  const RosMessage::imu *type_as_imu() const {
    return type_type() == RosMessage::Type_imu ? static_cast<const RosMessage::imu *>(type()) : nullptr;
  }
  const RosMessage::control *type_as_control() const {
    return type_type() == RosMessage::Type_control ? static_cast<const RosMessage::control *>(type()) : nullptr;
  }
  const RosMessage::time *type_as_time() const {
    return type_type() == RosMessage::Type_time ? static_cast<const RosMessage::time *>(type()) : nullptr;
  }
  const RosMessage::vehicle *type_as_vehicle() const {
    return type_type() == RosMessage::Type_vehicle ? static_cast<const RosMessage::vehicle *>(type()) : nullptr;
  }
  const RosMessage::cones *type_as_cones() const {
    return type_type() == RosMessage::Type_cones ? static_cast<const RosMessage::cones *>(type()) : nullptr;
  }
  const RosMessage::exit *type_as_exit() const {
    return type_type() == RosMessage::Type_exit ? static_cast<const RosMessage::exit *>(type()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyType(verifier, type(), type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const RosMessage::lidar *message::type_as<RosMessage::lidar>() const {
  return type_as_lidar();
}

template<> inline const RosMessage::gps *message::type_as<RosMessage::gps>() const {
  return type_as_gps();
}

template<> inline const RosMessage::imu *message::type_as<RosMessage::imu>() const {
  return type_as_imu();
}

template<> inline const RosMessage::control *message::type_as<RosMessage::control>() const {
  return type_as_control();
}

template<> inline const RosMessage::time *message::type_as<RosMessage::time>() const {
  return type_as_time();
}

template<> inline const RosMessage::vehicle *message::type_as<RosMessage::vehicle>() const {
  return type_as_vehicle();
}

template<> inline const RosMessage::cones *message::type_as<RosMessage::cones>() const {
  return type_as_cones();
}

template<> inline const RosMessage::exit *message::type_as<RosMessage::exit>() const {
  return type_as_exit();
}

struct messageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type_type(RosMessage::Type type_type) {
    fbb_.AddElement<uint8_t>(message::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(flatbuffers::Offset<void> type) {
    fbb_.AddOffset(message::VT_TYPE, type);
  }
  explicit messageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  messageBuilder &operator=(const messageBuilder &);
  flatbuffers::Offset<message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<message>(end);
    return o;
  }
};

inline flatbuffers::Offset<message> Createmessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    RosMessage::Type type_type = RosMessage::Type_NONE,
    flatbuffers::Offset<void> type = 0) {
  messageBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_type_type(type_type);
  return builder_.Finish();
}

struct lidar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4
  };
  const flatbuffers::Vector<const RosMessage::Vector *> *points() const {
    return GetPointer<const flatbuffers::Vector<const RosMessage::Vector *> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct lidarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> points) {
    fbb_.AddOffset(lidar::VT_POINTS, points);
  }
  explicit lidarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  lidarBuilder &operator=(const lidarBuilder &);
  flatbuffers::Offset<lidar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<lidar>(end);
    return o;
  }
};

inline flatbuffers::Offset<lidar> Createlidar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> points = 0) {
  lidarBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

inline flatbuffers::Offset<lidar> CreatelidarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<RosMessage::Vector> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<RosMessage::Vector>(*points) : 0;
  return RosMessage::Createlidar(
      _fbb,
      points__);
}

struct gps FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDE = 4,
    VT_LATITUDE = 6,
    VT_ALTITUDE = 8
  };
  float longitude() const {
    return GetField<float>(VT_LONGITUDE, 0.0f);
  }
  float latitude() const {
    return GetField<float>(VT_LATITUDE, 0.0f);
  }
  float altitude() const {
    return GetField<float>(VT_ALTITUDE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LONGITUDE) &&
           VerifyField<float>(verifier, VT_LATITUDE) &&
           VerifyField<float>(verifier, VT_ALTITUDE) &&
           verifier.EndTable();
  }
};

struct gpsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_longitude(float longitude) {
    fbb_.AddElement<float>(gps::VT_LONGITUDE, longitude, 0.0f);
  }
  void add_latitude(float latitude) {
    fbb_.AddElement<float>(gps::VT_LATITUDE, latitude, 0.0f);
  }
  void add_altitude(float altitude) {
    fbb_.AddElement<float>(gps::VT_ALTITUDE, altitude, 0.0f);
  }
  explicit gpsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gpsBuilder &operator=(const gpsBuilder &);
  flatbuffers::Offset<gps> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gps>(end);
    return o;
  }
};

inline flatbuffers::Offset<gps> Creategps(
    flatbuffers::FlatBufferBuilder &_fbb,
    float longitude = 0.0f,
    float latitude = 0.0f,
    float altitude = 0.0f) {
  gpsBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_latitude(latitude);
  builder_.add_longitude(longitude);
  return builder_.Finish();
}

struct imu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANGULAR_VELOCITY = 4,
    VT_LINEAR_ACCELERATION = 6,
    VT_ORIENTATION = 8
  };
  const RosMessage::Vector *angular_velocity() const {
    return GetStruct<const RosMessage::Vector *>(VT_ANGULAR_VELOCITY);
  }
  const RosMessage::Vector *linear_acceleration() const {
    return GetStruct<const RosMessage::Vector *>(VT_LINEAR_ACCELERATION);
  }
  const RosMessage::Vector *orientation() const {
    return GetStruct<const RosMessage::Vector *>(VT_ORIENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<RosMessage::Vector>(verifier, VT_ANGULAR_VELOCITY) &&
           VerifyField<RosMessage::Vector>(verifier, VT_LINEAR_ACCELERATION) &&
           VerifyField<RosMessage::Vector>(verifier, VT_ORIENTATION) &&
           verifier.EndTable();
  }
};

struct imuBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_angular_velocity(const RosMessage::Vector *angular_velocity) {
    fbb_.AddStruct(imu::VT_ANGULAR_VELOCITY, angular_velocity);
  }
  void add_linear_acceleration(const RosMessage::Vector *linear_acceleration) {
    fbb_.AddStruct(imu::VT_LINEAR_ACCELERATION, linear_acceleration);
  }
  void add_orientation(const RosMessage::Vector *orientation) {
    fbb_.AddStruct(imu::VT_ORIENTATION, orientation);
  }
  explicit imuBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  imuBuilder &operator=(const imuBuilder &);
  flatbuffers::Offset<imu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<imu>(end);
    return o;
  }
};

inline flatbuffers::Offset<imu> Createimu(
    flatbuffers::FlatBufferBuilder &_fbb,
    const RosMessage::Vector *angular_velocity = 0,
    const RosMessage::Vector *linear_acceleration = 0,
    const RosMessage::Vector *orientation = 0) {
  imuBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_linear_acceleration(linear_acceleration);
  builder_.add_angular_velocity(angular_velocity);
  return builder_.Finish();
}

struct vehicle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_VELOCITY = 6,
    VT_ACCELERATION = 8
  };
  const RosMessage::Vector *position() const {
    return GetStruct<const RosMessage::Vector *>(VT_POSITION);
  }
  const RosMessage::Vector *velocity() const {
    return GetStruct<const RosMessage::Vector *>(VT_VELOCITY);
  }
  const RosMessage::Vector *acceleration() const {
    return GetStruct<const RosMessage::Vector *>(VT_ACCELERATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<RosMessage::Vector>(verifier, VT_POSITION) &&
           VerifyField<RosMessage::Vector>(verifier, VT_VELOCITY) &&
           VerifyField<RosMessage::Vector>(verifier, VT_ACCELERATION) &&
           verifier.EndTable();
  }
};

struct vehicleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const RosMessage::Vector *position) {
    fbb_.AddStruct(vehicle::VT_POSITION, position);
  }
  void add_velocity(const RosMessage::Vector *velocity) {
    fbb_.AddStruct(vehicle::VT_VELOCITY, velocity);
  }
  void add_acceleration(const RosMessage::Vector *acceleration) {
    fbb_.AddStruct(vehicle::VT_ACCELERATION, acceleration);
  }
  explicit vehicleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  vehicleBuilder &operator=(const vehicleBuilder &);
  flatbuffers::Offset<vehicle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<vehicle>(end);
    return o;
  }
};

inline flatbuffers::Offset<vehicle> Createvehicle(
    flatbuffers::FlatBufferBuilder &_fbb,
    const RosMessage::Vector *position = 0,
    const RosMessage::Vector *velocity = 0,
    const RosMessage::Vector *acceleration = 0) {
  vehicleBuilder builder_(_fbb);
  builder_.add_acceleration(acceleration);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  return builder_.Finish();
}

struct control FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THROTTLE = 4,
    VT_STEERING = 6,
    VT_BRAKING = 8
  };
  float throttle() const {
    return GetField<float>(VT_THROTTLE, 0.0f);
  }
  float steering() const {
    return GetField<float>(VT_STEERING, 0.0f);
  }
  float braking() const {
    return GetField<float>(VT_BRAKING, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_THROTTLE) &&
           VerifyField<float>(verifier, VT_STEERING) &&
           VerifyField<float>(verifier, VT_BRAKING) &&
           verifier.EndTable();
  }
};

struct controlBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_throttle(float throttle) {
    fbb_.AddElement<float>(control::VT_THROTTLE, throttle, 0.0f);
  }
  void add_steering(float steering) {
    fbb_.AddElement<float>(control::VT_STEERING, steering, 0.0f);
  }
  void add_braking(float braking) {
    fbb_.AddElement<float>(control::VT_BRAKING, braking, 0.0f);
  }
  explicit controlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  controlBuilder &operator=(const controlBuilder &);
  flatbuffers::Offset<control> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<control>(end);
    return o;
  }
};

inline flatbuffers::Offset<control> Createcontrol(
    flatbuffers::FlatBufferBuilder &_fbb,
    float throttle = 0.0f,
    float steering = 0.0f,
    float braking = 0.0f) {
  controlBuilder builder_(_fbb);
  builder_.add_braking(braking);
  builder_.add_steering(steering);
  builder_.add_throttle(throttle);
  return builder_.Finish();
}

struct time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  float t() const {
    return GetField<float>(VT_T, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_T) &&
           verifier.EndTable();
  }
};

struct timeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_t(float t) {
    fbb_.AddElement<float>(time::VT_T, t, 0.0f);
  }
  explicit timeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  timeBuilder &operator=(const timeBuilder &);
  flatbuffers::Offset<time> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<time>(end);
    return o;
  }
};

inline flatbuffers::Offset<time> Createtime(
    flatbuffers::FlatBufferBuilder &_fbb,
    float t = 0.0f) {
  timeBuilder builder_(_fbb);
  builder_.add_t(t);
  return builder_.Finish();
}

struct cones FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLUE_CONES = 4,
    VT_YELLOW_CONES = 6
  };
  const flatbuffers::Vector<const RosMessage::Vector *> *blue_cones() const {
    return GetPointer<const flatbuffers::Vector<const RosMessage::Vector *> *>(VT_BLUE_CONES);
  }
  const flatbuffers::Vector<const RosMessage::Vector *> *yellow_cones() const {
    return GetPointer<const flatbuffers::Vector<const RosMessage::Vector *> *>(VT_YELLOW_CONES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLUE_CONES) &&
           verifier.VerifyVector(blue_cones()) &&
           VerifyOffset(verifier, VT_YELLOW_CONES) &&
           verifier.VerifyVector(yellow_cones()) &&
           verifier.EndTable();
  }
};

struct conesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blue_cones(flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> blue_cones) {
    fbb_.AddOffset(cones::VT_BLUE_CONES, blue_cones);
  }
  void add_yellow_cones(flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> yellow_cones) {
    fbb_.AddOffset(cones::VT_YELLOW_CONES, yellow_cones);
  }
  explicit conesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  conesBuilder &operator=(const conesBuilder &);
  flatbuffers::Offset<cones> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<cones>(end);
    return o;
  }
};

inline flatbuffers::Offset<cones> Createcones(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> blue_cones = 0,
    flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> yellow_cones = 0) {
  conesBuilder builder_(_fbb);
  builder_.add_yellow_cones(yellow_cones);
  builder_.add_blue_cones(blue_cones);
  return builder_.Finish();
}

inline flatbuffers::Offset<cones> CreateconesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<RosMessage::Vector> *blue_cones = nullptr,
    const std::vector<RosMessage::Vector> *yellow_cones = nullptr) {
  auto blue_cones__ = blue_cones ? _fbb.CreateVectorOfStructs<RosMessage::Vector>(*blue_cones) : 0;
  auto yellow_cones__ = yellow_cones ? _fbb.CreateVectorOfStructs<RosMessage::Vector>(*yellow_cones) : 0;
  return RosMessage::Createcones(
      _fbb,
      blue_cones__,
      yellow_cones__);
}

struct exit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4
  };
  int8_t code() const {
    return GetField<int8_t>(VT_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CODE) &&
           verifier.EndTable();
  }
};

struct exitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int8_t code) {
    fbb_.AddElement<int8_t>(exit::VT_CODE, code, 0);
  }
  explicit exitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  exitBuilder &operator=(const exitBuilder &);
  flatbuffers::Offset<exit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<exit>(end);
    return o;
  }
};

inline flatbuffers::Offset<exit> Createexit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t code = 0) {
  exitBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_lidar: {
      auto ptr = reinterpret_cast<const RosMessage::lidar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_gps: {
      auto ptr = reinterpret_cast<const RosMessage::gps *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_imu: {
      auto ptr = reinterpret_cast<const RosMessage::imu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_control: {
      auto ptr = reinterpret_cast<const RosMessage::control *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_time: {
      auto ptr = reinterpret_cast<const RosMessage::time *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_vehicle: {
      auto ptr = reinterpret_cast<const RosMessage::vehicle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_cones: {
      auto ptr = reinterpret_cast<const RosMessage::cones *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_exit: {
      auto ptr = reinterpret_cast<const RosMessage::exit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace RosMessage

#endif  // FLATBUFFERS_GENERATED_ROSMESSAGES_ROSMESSAGE_H_
