// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ROSMESSAGES_ROSMESSAGE_H_
#define FLATBUFFERS_GENERATED_ROSMESSAGES_ROSMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

namespace RosMessage {

struct Vector;

struct lidar;

struct gps;

struct imu;

struct vehicle;

struct control;

struct time;

struct cones;

struct exit;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector() {
    memset(static_cast<void *>(this), 0, sizeof(Vector));
  }
  Vector(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector, 12);

struct lidar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4
  };
  const flatbuffers::Vector<const RosMessage::Vector *> *points() const {
    return GetPointer<const flatbuffers::Vector<const RosMessage::Vector *> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct lidarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> points) {
    fbb_.AddOffset(lidar::VT_POINTS, points);
  }
  explicit lidarBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  lidarBuilder &operator=(const lidarBuilder &);
  flatbuffers::Offset<lidar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<lidar>(end);
    return o;
  }
};

inline flatbuffers::Offset<lidar> Createlidar(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> points = 0) {
  lidarBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

inline flatbuffers::Offset<lidar> CreatelidarDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<RosMessage::Vector> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<RosMessage::Vector>(*points) : 0;
  return RosMessage::Createlidar(
      _fbb,
      points__);
}

struct gps FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDE = 4,
    VT_LATITUDE = 6,
    VT_ALTITUDE = 8
  };
  float longitude() const {
    return GetField<float>(VT_LONGITUDE, 0.0f);
  }
  float latitude() const {
    return GetField<float>(VT_LATITUDE, 0.0f);
  }
  float altitude() const {
    return GetField<float>(VT_ALTITUDE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LONGITUDE) &&
           VerifyField<float>(verifier, VT_LATITUDE) &&
           VerifyField<float>(verifier, VT_ALTITUDE) &&
           verifier.EndTable();
  }
};

struct gpsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_longitude(float longitude) {
    fbb_.AddElement<float>(gps::VT_LONGITUDE, longitude, 0.0f);
  }
  void add_latitude(float latitude) {
    fbb_.AddElement<float>(gps::VT_LATITUDE, latitude, 0.0f);
  }
  void add_altitude(float altitude) {
    fbb_.AddElement<float>(gps::VT_ALTITUDE, altitude, 0.0f);
  }
  explicit gpsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gpsBuilder &operator=(const gpsBuilder &);
  flatbuffers::Offset<gps> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gps>(end);
    return o;
  }
};

inline flatbuffers::Offset<gps> Creategps(
    flatbuffers::FlatBufferBuilder &_fbb,
    float longitude = 0.0f,
    float latitude = 0.0f,
    float altitude = 0.0f) {
  gpsBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_latitude(latitude);
  builder_.add_longitude(longitude);
  return builder_.Finish();
}

struct imu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANGULAR_VELOCITY = 4,
    VT_LINEAR_ACCELERATION = 6,
    VT_ORIENTATION = 8
  };
  const RosMessage::Vector *angular_velocity() const {
    return GetStruct<const RosMessage::Vector *>(VT_ANGULAR_VELOCITY);
  }
  const RosMessage::Vector *linear_acceleration() const {
    return GetStruct<const RosMessage::Vector *>(VT_LINEAR_ACCELERATION);
  }
  const RosMessage::Vector *orientation() const {
    return GetStruct<const RosMessage::Vector *>(VT_ORIENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<RosMessage::Vector>(verifier, VT_ANGULAR_VELOCITY) &&
           VerifyField<RosMessage::Vector>(verifier, VT_LINEAR_ACCELERATION) &&
           VerifyField<RosMessage::Vector>(verifier, VT_ORIENTATION) &&
           verifier.EndTable();
  }
};

struct imuBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_angular_velocity(const RosMessage::Vector *angular_velocity) {
    fbb_.AddStruct(imu::VT_ANGULAR_VELOCITY, angular_velocity);
  }
  void add_linear_acceleration(const RosMessage::Vector *linear_acceleration) {
    fbb_.AddStruct(imu::VT_LINEAR_ACCELERATION, linear_acceleration);
  }
  void add_orientation(const RosMessage::Vector *orientation) {
    fbb_.AddStruct(imu::VT_ORIENTATION, orientation);
  }
  explicit imuBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  imuBuilder &operator=(const imuBuilder &);
  flatbuffers::Offset<imu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<imu>(end);
    return o;
  }
};

inline flatbuffers::Offset<imu> Createimu(
    flatbuffers::FlatBufferBuilder &_fbb,
    const RosMessage::Vector *angular_velocity = 0,
    const RosMessage::Vector *linear_acceleration = 0,
    const RosMessage::Vector *orientation = 0) {
  imuBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_linear_acceleration(linear_acceleration);
  builder_.add_angular_velocity(angular_velocity);
  return builder_.Finish();
}

struct vehicle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4
  };
  const RosMessage::Vector *position() const {
    return GetStruct<const RosMessage::Vector *>(VT_POSITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<RosMessage::Vector>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct vehicleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const RosMessage::Vector *position) {
    fbb_.AddStruct(vehicle::VT_POSITION, position);
  }
  explicit vehicleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  vehicleBuilder &operator=(const vehicleBuilder &);
  flatbuffers::Offset<vehicle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<vehicle>(end);
    return o;
  }
};

inline flatbuffers::Offset<vehicle> Createvehicle(
    flatbuffers::FlatBufferBuilder &_fbb,
    const RosMessage::Vector *position = 0) {
  vehicleBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

struct control FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THROTTLE = 4,
    VT_STEERING = 6,
    VT_BRAKING = 8
  };
  float throttle() const {
    return GetField<float>(VT_THROTTLE, 0.0f);
  }
  float steering() const {
    return GetField<float>(VT_STEERING, 0.0f);
  }
  float braking() const {
    return GetField<float>(VT_BRAKING, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_THROTTLE) &&
           VerifyField<float>(verifier, VT_STEERING) &&
           VerifyField<float>(verifier, VT_BRAKING) &&
           verifier.EndTable();
  }
};

struct controlBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_throttle(float throttle) {
    fbb_.AddElement<float>(control::VT_THROTTLE, throttle, 0.0f);
  }
  void add_steering(float steering) {
    fbb_.AddElement<float>(control::VT_STEERING, steering, 0.0f);
  }
  void add_braking(float braking) {
    fbb_.AddElement<float>(control::VT_BRAKING, braking, 0.0f);
  }
  explicit controlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  controlBuilder &operator=(const controlBuilder &);
  flatbuffers::Offset<control> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<control>(end);
    return o;
  }
};

inline flatbuffers::Offset<control> Createcontrol(
    flatbuffers::FlatBufferBuilder &_fbb,
    float throttle = 0.0f,
    float steering = 0.0f,
    float braking = 0.0f) {
  controlBuilder builder_(_fbb);
  builder_.add_braking(braking);
  builder_.add_steering(steering);
  builder_.add_throttle(throttle);
  return builder_.Finish();
}

struct time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  float t() const {
    return GetField<float>(VT_T, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_T) &&
           verifier.EndTable();
  }
};

struct timeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_t(float t) {
    fbb_.AddElement<float>(time::VT_T, t, 0.0f);
  }
  explicit timeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  timeBuilder &operator=(const timeBuilder &);
  flatbuffers::Offset<time> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<time>(end);
    return o;
  }
};

inline flatbuffers::Offset<time> Createtime(
    flatbuffers::FlatBufferBuilder &_fbb,
    float t = 0.0f) {
  timeBuilder builder_(_fbb);
  builder_.add_t(t);
  return builder_.Finish();
}

struct cones FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLUE_CONES = 4,
    VT_YELLOW_CONES = 6
  };
  const flatbuffers::Vector<const RosMessage::Vector *> *blue_cones() const {
    return GetPointer<const flatbuffers::Vector<const RosMessage::Vector *> *>(VT_BLUE_CONES);
  }
  const flatbuffers::Vector<const RosMessage::Vector *> *yellow_cones() const {
    return GetPointer<const flatbuffers::Vector<const RosMessage::Vector *> *>(VT_YELLOW_CONES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLUE_CONES) &&
           verifier.VerifyVector(blue_cones()) &&
           VerifyOffset(verifier, VT_YELLOW_CONES) &&
           verifier.VerifyVector(yellow_cones()) &&
           verifier.EndTable();
  }
};

struct conesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blue_cones(flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> blue_cones) {
    fbb_.AddOffset(cones::VT_BLUE_CONES, blue_cones);
  }
  void add_yellow_cones(flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> yellow_cones) {
    fbb_.AddOffset(cones::VT_YELLOW_CONES, yellow_cones);
  }
  explicit conesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  conesBuilder &operator=(const conesBuilder &);
  flatbuffers::Offset<cones> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<cones>(end);
    return o;
  }
};

inline flatbuffers::Offset<cones> Createcones(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> blue_cones = 0,
    flatbuffers::Offset<flatbuffers::Vector<const RosMessage::Vector *>> yellow_cones = 0) {
  conesBuilder builder_(_fbb);
  builder_.add_yellow_cones(yellow_cones);
  builder_.add_blue_cones(blue_cones);
  return builder_.Finish();
}

inline flatbuffers::Offset<cones> CreateconesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<RosMessage::Vector> *blue_cones = nullptr,
    const std::vector<RosMessage::Vector> *yellow_cones = nullptr) {
  auto blue_cones__ = blue_cones ? _fbb.CreateVectorOfStructs<RosMessage::Vector>(*blue_cones) : 0;
  auto yellow_cones__ = yellow_cones ? _fbb.CreateVectorOfStructs<RosMessage::Vector>(*yellow_cones) : 0;
  return RosMessage::Createcones(
      _fbb,
      blue_cones__,
      yellow_cones__);
}

struct exit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4
  };
  int8_t code() const {
    return GetField<int8_t>(VT_CODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CODE) &&
           verifier.EndTable();
  }
};

struct exitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int8_t code) {
    fbb_.AddElement<int8_t>(exit::VT_CODE, code, 0);
  }
  explicit exitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  exitBuilder &operator=(const exitBuilder &);
  flatbuffers::Offset<exit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<exit>(end);
    return o;
  }
};

inline flatbuffers::Offset<exit> Createexit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t code = 0) {
  exitBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

}  // namespace RosMessage

#endif  // FLATBUFFERS_GENERATED_ROSMESSAGES_ROSMESSAGE_H_
